<!DOCTYPE html>
<html lang="en-us"><head>
    <title></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="" />
    <style>
@import "https://fonts.googleapis.com/css2?family=Inconsolata&display=swap";html,body{width:100%;height:100%;overflow:auto;font-family:inconsolata,monospace;font-size:4vmin;line-height:4.1vmin;font-weight:400}body{margin:0;display:flex;flex-direction:row;justify-content:center;align-items:center}#content{min-width:82vmin;min-height:82vmin}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-track{border-radius:10px;box-shadow:inset 0 0 1px white}::-webkit-scrollbar-thumb{border-radius:10px;box-shadow:0 0 0 1px white}@media only screen and (min-width:768px){body{font-size:2.5vmin;line-height:2.6vmin}#content{min-width:60vmin}}body{align-items:unset;overflow-y:scroll}#content{max-width:80vmin}pre{overflow-x:scroll;white-space:pre}









body{background:#1b1d1e}body #terminal{color:#bbb}body #user{color:#23e298}body #dir{color:#d08010}body .Typewriter__cursor{color:#bbb}a{color:#bbb}</style>

</head><body>
    
<div id="content">
    
    

    
    
    <div id=typewriter></div>
    <script src="https://cdn.jsdelivr.net/gh/tameemsafi/typewriterjs/dist/core.js"></script>
    <script type="text/javascript">
        const instance = new Typewriter('#typewriter', {
            strings: '\u003cspan id=terminal\u003e\u003ch1 id=\u0027title\u0027\u003e\u003c\/h1\u003e\u003ch1 id=\u0022til-62221\u0022\u003eTIL 6\/22\/21\u003c\/h1\u003e\n\u003ch3 id=\u0022쿠키의-스코프\u0022\u003e쿠키의 스코프\u003c\/h3\u003e\n\u003ch5 id=\u00221-탭-간에-공유되는가\u0022\u003e1. 탭 간에 공유되는가?\u003c\/h5\u003e\n\u003ch5 id=\u00222-새-창을-열면-새로운-세션이-맺어지는가\u0022\u003e2. 새 창을 열면 새로운 세션이 맺어지는가?\u003c\/h5\u003e\n\u003ch5 id=\u00223-쿠키는-포트간에-공유되는가\u0022\u003e3. 쿠키는 포트간에 공유되는가?\u003c\/h5\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCookies do not provide isolation by port\u003c\/strong\u003e. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server. If a cookie is writable by a service on one port, the cookie is also writable by a service running on another port of the same server. For this reason, servers SHOULD NOT both run mutually distrusting services on different ports of the same host and use cookies to store security sensitive information.\u003c\/p\u003e\n\u003cp\u003e하나의 포트에서 쿠키를 읽고 쓸 수 있으면 다른 포트에서도 마찬가지로 읽고 쓸 수 있다. 이런 이유로 \u003cstrong\u003e같은 호스트의 다른 포트에서 상호 신뢰하지 않는 서비스를 실행하거나 보안에 민감한 정보를 쿠키에 담아선 안된다.\u003c\/strong\u003e\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003ch5 id=\u00224-쿠키는-브라우저-로컬에-저장-참조한다\u0022\u003e4. 쿠키는 브라우저 로컬에 저장, 참조한다.\u003c\/h5\u003e\n\u003ch5 id=\u00225-다른-포트로-접속한다고-새로운-쿠키를-발급하지-않는다\u0022\u003e5. 다른 포트로 접속한다고 새로운 쿠키를 발급하지 않는다.\u003c\/h5\u003e\n\u003ch5 id=\u00226-cookie-secure-옵션을-주면-https-에서만-공유된다\u0022\u003e6. cookie secure 옵션을 주면 https 에서만 공유된다.\u003c\/h5\u003e\n\u003cblockquote\u003e\n\u003cp\u003e동일 서버에서 2개의 포트를 띄우고 각각 https와 http 웹을 띄울 경우 ?  https 웹에 쿠키 옵션을 secure로 줄 경우 https 웹에 먼저 접속하여 세션을 맺고 다른 포트로 접근 시 쿠키가 공유되지 않음. 모든 포트를 TLS로 띄워야 함.\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003ch2 id=\u0022resources\u0022\u003eResources\u003c\/h2\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/nsinc.tistory.com\/121\u0022\u003ecookie secure 옵션 ?\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/www.hahwul.com\/2020\/01\/18\/samesite-lax\/#section_3\u0022\u003ecookie same-site 옵션 ?\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/jeong-pro.tistory.com\/80\u0022\u003ecookie와 session\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/medium.com\/swlh\/7-keys-to-the-mystery-of-a-missing-cookie-fdf22b012f09\u0022\u003ecookie trouble shooting\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/stackoverflow.com\/questions\/1612177\/are-http-cookies-port-specific\u0022\u003ecookie는 포트간에 공유되는가?\u003c\/a\u003e\u003c\/p\u003e\n\u003ch3 id=\u0022리액트-slots-패턴\u0022\u003e리액트 slots 패턴\u003c\/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWarning: Failed prop type: Invalid prop \u003ccode\u003echildren\u003c\/code\u003e of type \u003ccode\u003earray\u003c\/code\u003e supplied to \u003ccode\u003eAdminWrapper\u003c\/code\u003e, expected a single ReactElement\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003ch5 id=\u0022jsx-엘리먼트도-일반-named-props로-넘길-수-있다\u0022\u003eJSX 엘리먼트도 일반 named props로 넘길 수 있다.\u003c\/h5\u003e\n\u003ch3 id=\u0022resource\u0022\u003eResource\u003c\/h3\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/daveceddia.com\/pluggable-slots-in-react-components\/\u0022\u003ereact pattern : slots\u003c\/a\u003e\u003c\/p\u003e\n\u003ch3 id=\u0022abortcontroller\u0022\u003eAbortController\u003c\/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWarning: Can\u0026rsquo;t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003cp\u003e비동기와 이벤트를 다룰 때는 메모리 릭이  일어날 수 있으므로 사이드 이펙트에 클린업을 꼭 해주는 것이 좋다.\u003c\/p\u003e\n\u003cp\u003e이벤트 리스너는 removeEventListener 하면 되지만 비동기 호출은 어떻게 해야할까?\u003c\/p\u003e\n\u003chr\u003e\n\u003ch3 id=\u0022resources-1\u0022\u003eResources\u003c\/h3\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/dev.to\/pallymore\/clean-up-async-requests-in-useeffect-hooks-90h\u0022\u003efetch 에서 AbortController 사용하기\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/falsy.me\/%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9A%94%EC%B2%AD-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-abortcontroller\/\u0022\u003eAxios에서는 어떻게\u003c\/a\u003e\u003c\/p\u003e\n\u003cp\u003e\u003ca href=\u0022https:\/\/github.com\/axios\/axios#cancellation\u0022\u003eAxios cancellation github\u003c\/a\u003e\u003c\/p\u003e\n\u003c\/span\u003e',
            delay: '0.1',
            autoStart: true,
        });
    </script>


        </div></body>
</html>
