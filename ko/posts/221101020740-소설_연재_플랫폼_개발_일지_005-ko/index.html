<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="다시 shadow-grove로 # 레퍼런스가 없어서 힘들었었는데 다시 해보니 뭔가 알 것 같다. shadow-cljs를 개발한 thheller가 만들고 있는 cljs 프레임워크인데 하나 하나 설명을 읽어가면서 개척해나가는 재미가 나름 있다. 당연하게 여겼던 hot-reload도 여기서는 직접 구현해야 했다. 다행히 thheller 이 분이 Hot Reload in ClojureScript 라는 아티클을 남겨두셔서 조금 이해할 수 있었다. 나중에 꼭 번역을 해둬야겠다.
Css 관련 배운 것 # css는 가능한 static하게 서빙하는 게 좋다고 한다. 동적으로 런타임에 css를 빌드하게 되면 그만큼 사용자에게 그 비용을 전가하게 된다."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="소설 연재 플랫폼 개발 일지 005"><meta property="og:description" content="다시 shadow-grove로 # 레퍼런스가 없어서 힘들었었는데 다시 해보니 뭔가 알 것 같다. shadow-cljs를 개발한 thheller가 만들고 있는 cljs 프레임워크인데 하나 하나 설명을 읽어가면서 개척해나가는 재미가 나름 있다. 당연하게 여겼던 hot-reload도 여기서는 직접 구현해야 했다. 다행히 thheller 이 분이 Hot Reload in ClojureScript 라는 아티클을 남겨두셔서 조금 이해할 수 있었다. 나중에 꼭 번역을 해둬야겠다.
Css 관련 배운 것 # css는 가능한 static하게 서빙하는 게 좋다고 한다. 동적으로 런타임에 css를 빌드하게 되면 그만큼 사용자에게 그 비용을 전가하게 된다."><meta property="og:type" content="article"><meta property="og:url" content="http://krapjost.github.io/ko/posts/221101020740-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_005-ko/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-01T02:07:00+09:00"><meta property="article:modified_time" content="2022-11-01T04:14:34+09:00"><meta property="og:site_name" content="정원"><title>소설 연재 플랫폼 개발 일지 005 | 정원</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.3e7c6d989fa733ee22d0bab8709297e4c2385a45ce37d75d9d094ef135aa42fb.css integrity="sha256-PnxtmJ+nM+4i0Lq4cJKX5MI4WkXON9ddnQlO8TWqQvs=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/ko.search.min.1d6eceb6180226172a1f153bde2ad752c6c26d74fb2c232404cf0a3edb48b50b.js integrity="sha256-HW7OthgCJhcqHxU73irXUsbCbXT7LCMkBM8KPttItQs=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>정원</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=검색 aria-label=검색 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=http://krapjost.github.io/>English</a></li></ul></li></ul><ul><li><a href=/ko/posts/>기록들</a></li></ul><ul><li><a href=/ko/resume/>이력서</a></li><li><a href=https://github.com/krapjost target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>소설 연재 플랫폼 개발 일지 005</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#다시-shadow-grove로>다시 shadow-grove로</a></li><li><a href=#css-관련-배운-것>Css 관련 배운 것</a><ul><li><a href=#jvm-memory-사용량>Jvm memory 사용량</a></li><li><a href=#shadow-grove에는-shadow-css>shadow-grove에는 shadow-css</a></li></ul></li><li><a href=#해결-못한-문제>해결 못한 문제</a></li></ul></nav></aside></header><article class=markdown><h1><a href=/ko/posts/221101020740-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_005-ko/>소설 연재 플랫폼 개발 일지 005</a></h1><h5>November 1, 2022</h5><div><a href=/ko/categories/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/>개발일지</a></div><div><a href=/ko/tags/clojurescript/>clojurescript</a></div><h2 id=다시-shadow-grove로>다시 shadow-grove로
<a class=anchor href=#%eb%8b%a4%ec%8b%9c-shadow-grove%eb%a1%9c>#</a></h2><p>레퍼런스가 없어서 힘들었었는데 다시 해보니 뭔가 알 것 같다.
<a href=https://github.com/thheller/shadow-cljs>shadow-cljs</a>를 개발한 <a href=https://github.com/thheller>thheller</a>가 만들고 있는 cljs 프레임워크인데 하나 하나 설명을 읽어가면서 개척해나가는 재미가 나름 있다.
당연하게 여겼던 hot-reload도 여기서는 직접 구현해야 했다. 다행히 thheller 이 분이 <a href=https://code.thheller.com/blog/shadow-cljs/2019/08/25/hot-reload-in-clojurescript.html>Hot Reload in ClojureScript</a> 라는 아티클을 남겨두셔서 조금 이해할 수 있었다. 나중에 꼭 번역을 해둬야겠다.</p><h2 id=css-관련-배운-것>Css 관련 배운 것
<a class=anchor href=#css-%ea%b4%80%eb%a0%a8-%eb%b0%b0%ec%9a%b4-%ea%b2%83>#</a></h2><p>css는 가능한 static하게 서빙하는 게 좋다고 한다. 동적으로 런타임에 css를 빌드하게 되면 그만큼 사용자에게 그 비용을 전가하게 된다.</p><h3 id=jvm-memory-사용량>Jvm memory 사용량
<a class=anchor href=#jvm-memory-%ec%82%ac%ec%9a%a9%eb%9f%89>#</a></h3><p>원래 css로 tailwind를 써보다가 빌드 훅을 잘못 짰는지 빌드 할 때마다 jvm 메모리 사용량이 40% 까지 올라가곤 했는데
다음 옵션을 shadow-cljs.edn에 명기함으로써 램을 최대 1G 까지만 사용하라고 정해줄 수 있었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span> <span style=color:#e6db74>:jvm-opts</span>
</span></span><span style=display:flex><span> [<span style=color:#e6db74>&#34;-Xmx1G&#34;</span>]
</span></span></code></pre></div><h3 id=shadow-grove에는-shadow-css>shadow-grove에는 shadow-css
<a class=anchor href=#shadow-grove%ec%97%90%eb%8a%94-shadow-css>#</a></h3><p>tailwind를 따로 의존성에 추가하지 않아도 된다. tailwind config 파일을 따로 관리하지 않아도 되어서 너무 좋다.
메모리 제한을 둬서 그런지 몰라도 css 빌드 훅도 안정적이고 훨씬 빠르게 적용된다.</p><p>아래는 shadow-css 리포지터리의 <a href=https://github.com/thheller/shadow-css#development-builds>css dev-build</a> 를 참고하여 작성해본 빌드 훅이다.
현재는 cljs를 js로 빌드할 때마다 전체 css 파일을 다시 쓰고 있는데 더 나은 방법은 없을까&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>ns </span>app.css
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>:require</span>
</span></span><span style=display:flex><span>   [clojure.java.io <span style=color:#e6db74>:as</span> io]
</span></span><span style=display:flex><span>   [shadow.css.build <span style=color:#e6db74>:as</span> cb]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defonce </span>css-ref (<span style=color:#a6e22e>atom</span> nil))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>generate-css []
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>reset!</span> css-ref
</span></span><span style=display:flex><span>          (-&gt; (<span style=color:#a6e22e>cb/start</span>)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>cb/index-path</span> (<span style=color:#a6e22e>io/file</span> <span style=color:#e6db74>&#34;src&#34;</span> <span style=color:#e6db74>&#34;main&#34;</span>) {})))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; 변경된 pulp.app 네임스페이스의 코드를 읽어 pulp.css 파일로 빌드하여 public/css/ 디렉터리에 쓴다.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; wildcard인 별표로 pulp.app를 다 보고 있지만 css 생성만 담당하는 파일을 만들어 해당 파일이 변경될 때만</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; css를 생성하도록 로직을 변경해봐야겠다.</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>[result
</span></span><span style=display:flex><span>        (-&gt; <span style=color:#f92672>@</span>css-ref
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>cb/generate</span> <span style=color:#f92672>&#39;</span>{<span style=color:#e6db74>:pulp</span> {<span style=color:#e6db74>:include</span> [pulp.app*]}})
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>cb/write-outputs-to</span> (<span style=color:#a6e22e>io/file</span> <span style=color:#e6db74>&#34;public&#34;</span> <span style=color:#e6db74>&#34;css&#34;</span>)))]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (prn <span style=color:#e6db74>&#34;css generated&#34;</span>)
</span></span><span style=display:flex><span>    (doseq [mod (<span style=color:#e6db74>:outputs</span> result)
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:keys</span> [warning-type] <span style=color:#e6db74>:as</span> warning} (<span style=color:#e6db74>:warnings</span> mod)]
</span></span><span style=display:flex><span>      (prn [<span style=color:#e6db74>:CSS</span> (name warning-type) (dissoc warning <span style=color:#e6db74>:warning-type</span>)]))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>println</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>gen
</span></span><span style=display:flex><span>  {<span style=color:#e6db74>:shadow.build/stage</span> <span style=color:#e6db74>:flush</span>}
</span></span><span style=display:flex><span>  [build-state]
</span></span><span style=display:flex><span>  (prn <span style=color:#e6db74>&#34;generating css...&#34;</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>generate-css</span>)
</span></span><span style=display:flex><span>  build-state)
</span></span></code></pre></div><p>작성자는 fs-watcher를 추가하여 빌드 훅이 아니라 repl을 통해 따로 프로세스를 띄워두는 것 같은데
나는 아무리 해도 어떻게 하는건지 모르겠어서 그냥 빌드 훅으로 적용했다.</p><h2 id=해결-못한-문제>해결 못한 문제
<a class=anchor href=#%ed%95%b4%ea%b2%b0-%eb%aa%bb%ed%95%9c-%eb%ac%b8%ec%a0%9c>#</a></h2><ol><li>clojure-lsp classpath를 못 읽는건지 자꾸 잘 작동하는 코드에 에러 메시지를 띄운다.
<code>shadow-cljs classpath</code> 하면 shadow-grove가 있는 것이 확인되는데 관련 코드를 인식 못한다.
<code>unresolved symbol</code> 어떻게 해결해야 할지 모르겠다. 그냥 lsp 끄고 써야하나.</li></ol><hr><div class=bl-section><h4>Links to this note</h4><div class=backlinks><ul><li><a href=/ko/posts/221101035735-clj_kondo-ko/>clj-kondo</a></li></ul></div></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#다시-shadow-grove로>다시 shadow-grove로</a></li><li><a href=#css-관련-배운-것>Css 관련 배운 것</a><ul><li><a href=#jvm-memory-사용량>Jvm memory 사용량</a></li><li><a href=#shadow-grove에는-shadow-css>shadow-grove에는 shadow-css</a></li></ul></li><li><a href=#해결-못한-문제>해결 못한 문제</a></li></ul></nav></div></aside></main></body></html>