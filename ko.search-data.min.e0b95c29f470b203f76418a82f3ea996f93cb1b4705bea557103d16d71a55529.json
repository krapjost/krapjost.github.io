[{"id":0,"href":"/ko/posts/221114144112-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_008-ko/","title":"221114144112 소설 연재 플랫폼 개발 일지 008 Ko 소설 연재 플랫폼 개발 일지 008","section":"기록들","content":"프론트 페이지 라우팅 작업이 끝나고 백엔드 데이터 베이스 구조를 고민하고 있다. 추천 알고리즘을 구현해보고 싶어 조사 중 그래프DB를 알게되어서 공부 중.\n소설 연재 플랫폼이면서 동시에 소셜 네트워킹 플랫폼의 역할도 했으면 좋겠다. 내가 좋아하는 소설, 그 소설을 좋아하는 유저들, 그 유저들이 좋아하는 소설. 내가 좋아하는 소설을 쓴 작가가 좋아하는 소설.\n좋아한다는게 무엇인지에 대한 생각도 해야할 것 같다. 좋아요를 눌러놓고 잘 보지 않게 되는 글도 있고 그냥 보다보니 끝까지 보게되는 글도 있으니까.\n지금 내게 가장 어려운 문제는 글 데이터를 어떻게 보관하는 것이 최선일까이다. 그래프DB가 DocumentDB에 관계 메타 데이터 레이어를 추가한 것이라고 이해하고 있는데 그렇다면 글을 보관하기 위한 다른 DB를 사용하지 않아도 괜찮은 것일까.\n가능하다면 글을 작성할 때 본인이 작성한 글들 안에서 full-text-search가 되게끔 하고싶다. meilisearch로 구텐베르그 프로젝트 글들을 실시간 검색하는 것을 실험해 보았는데 인덱싱을 마치고 나니 10기가 바이트가 추가로 더 생겨서 모든 글을 인덱싱하는 것은 무리인 것 같다.\n한다면 일반 유저들은 글 제목 등의 메타 데이터만 검색할 수 있게 하고, 후에 비용을 지불한 작가 유저들에게만 제공되는 기능으로 해야할 것 같다.\n"},{"id":1,"href":"/ko/posts/221112235354-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_007-ko/","title":"소설 연재 플랫폼 개발 일지 007","section":"기록들","content":" 배운 것 # wallmart에서 개발한 graphQL clojure 구현체 lacinia. 그린랩스에서도 이것을 쓰고 있다. graphQL은 정말 편하다. 성능? 성능 이슈에 대한 글도 있지만 DB를 그래프DB를 쓰면 신경쓰지 않아도 되지 않을까 하는 생각이 든다. RDB에서는 복잡한 쿼리를 한 번에 수행하는데 지수 시간이 걸리지만 그래프DB는 상수 시간으로 쿼리할 수 있다. 어쨌거나 모바일 우선 앱을 만들고 싶기 때문에 graphQL은 좋은 선택이 될 것 같다. Web client \u0026lt;-\u0026gt; http-server \u0026lt;-\u0026gt; graphql resolver \u0026lt;-\u0026gt; docker(datalevin)\nGet users IP addr and it\u0026rsquo;s geo-location -\u0026gt; store it into datalevin. When user likes or set alarm on book, copy data to CDN. When user starts to read, fetch and store next episode into clients in-memory db. 추천 알고리즘은 대충 어떤건지 이해가 되는데 별점 테러를 악의적으로 한다거나 하는 악성 유저들을 탐지하는 것은 어떻게 한다는 건지 모르겠다. 대충 IP 주소를 저장해두고 같은 주소에서 다른 아이디로 접속하여 동일한 행동을 한다면 차단을 하는 식인가?\n"},{"id":2,"href":"/ko/posts/221109170247-shadow_grove-ko/","title":"shadow-grove-","section":"기록들","content":" 컴포넌트 리스트 그리는 방법 # 아래와 같은 데이터와\n(def book-list {:section \u0026#34;Today\u0026#34; :list [{:id \u0026#34;0\u0026#34; :name \u0026#34;book1\u0026#34; :author \u0026#34;doong\u0026#34; :description \u0026#34;rorlame edalkwdqd qwlmdkwmd ql\u0026#34;} {:id \u0026#34;1\u0026#34; :name \u0026#34;book2\u0026#34; :author \u0026#34;ojo\u0026#34; :description \u0026#34;heleld qwdmlkqwd awlkda wk\u0026#34;}]} {:section \u0026#34;Weekly\u0026#34; :list [{:id \u0026#34;4\u0026#34; :name \u0026#34;book5\u0026#34; :author \u0026#34;asdw\u0026#34; :description \u0026#34;asdawd\u0026#34;} {:id \u0026#34;6\u0026#34; :name \u0026#34;book7\u0026#34; :author \u0026#34;qw w w\u0026#34; :description \u0026#34;wqlwd qwldkm qwlkdasd asd\u0026#34;}]}) 아래와 같은 컴포넌트가 있을 때\n(defc book-card [{:keys [name author description]}] (render (\u0026lt;\u0026lt; [:a {:class (css :relative :block :h-96)} [:span {:class (css :absolute :inset-0 :border-2 :border-dashed :border-black)}] [:div {:class (css :relative :flex :h-full :items-end :border-2 :border-black :bg-white :transition-transform [:hover {:transform \u0026#34;translate(-0.5rem, -0.5rem)\u0026#34;}])} [:div {:class (css :px-8 :pb-8 :transition-opacity [:hover :absolute :opacity-0])} [:h2 {:class (css :mt-4 :text-2xl :font-medium)} name] [:h3 author]] [:div {:class (css :absolute :p-8 :opacity-0 :transition-opacity [:hover :relative :opacity-100])} [:h2 {:class (css :mt-4 :text-2xl :font-medium)} name] [:h3 author] [:p {:class (css :mt-4)} description] [:p {:class (css :mt-8 :font-bold)} \u0026#34;읽어보기\u0026#34;]]]]))) keyed-seq 를 사용해 book-list 데이터를 풀어 book-card에 전해줄 수 있다. 이때 2번 째 아규먼트는 키 함수인데 키워드를 통해 키 중복을 방지할 수 있다. 키 대신 identity 를 넣으면 모든 데이터에 중복이 없어야 렌더링 된다.\n(sg/keyed-seq book-list :id book-card) "},{"id":3,"href":"/ko/posts/221108151034-greenlabs_bootcamp-ko/","title":"greenlabs-bootcamp","section":"기록들","content":" 함수형은 # 익숙해? 고등학교 2학년 과정에 있음\nhttp://blog.jenkster.com/2015/12/what-is-functional-programming.html\n두 뿌리 # 튜링 기계 언어 # 기계에 명령하기 위함\n람다 계산 언어 ( Alonzo church ) # 값을 계산하기 위함 ( Applicative language )\n자바 스트림?\n추상화의 스펙트럼 # goto -\u0026gt;\u0026gt; for loop -\u0026gt;\u0026gt; map/filter/reduce https://www.youtube.com/watch?v=mVVNJKv9esE\n닐 포드 함수형 사고\nDev dive 2022 # Why functional programming matters # https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf 모듈식 설계 분해와 좋은 조립이 핵심이다.\n조립 수단 # 고차 함수 지연 평가 (lazy eval) 지연평가가 왜 좋은가 rtfeldman - why functional programming isn\u0026rsquo;t norm # IEEE 잡지 Why functional programming should be the future of software development # constacts liftIO 김은민 # 쏙쏙 들어오는 함수형 코딩 저자\nconstacts 스택 # GCP + kubernetes + github action + GHCup + Haskell tool stack + postgresql + GraphQL + Kafka\n도메인? # [Types \u0026lt;- Service] \u0026lt;- [ 나머지 ( DB, GraphQL resolver, 외부 SASS ) ] -\u0026gt; Kafka ( 엔티티 변경 이벤트 발생 ) postgresql-typed 뷰는 도메인에 의존하지 않고 다른 타입을 만들었다\n테스트? # 유닛테스트와 통합테스트 -\u0026gt; 테스트서버와 테스트DB\nPolylith # repo core ( base ) lambda ( 날씨 ) lambda ( 가격 ) lambda \u0026hellip; 배포 사이즈 # 증분 테스트 # 태그 이후의 변경 사항에 대해서만 테스트 ( 브릭 )\n데이터 시각화 # stuart halloway repl driven development Tap, Portal\n가시성 # 잘 볼 수 있는 툴\n탐색성 # amazon-correto17 jvm gosura graphql\n"},{"id":4,"href":"/ko/posts/221107200152-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_006-ko/","title":"소설 연재 플랫폼 개발 일지 006","section":"기록들","content":" 익숙해지는 중 # shadow-css에는 tailwind 방식의 별칭을 사용해 스타일링 할 수 있다. 다른 점은, tailwind가 별칭마다 클래스를 부여하고 그 클래스들은 다 이미 정의되어 있는데 반해, shadow-css는 styled-component처럼 컴포넌트마다 하나의 클래스를 배정한다. tailwind는 프로덕션 빌드 때 사용되지 않는 클래스들을 날린(purge)한 css파일을 얻을 수 있다. shadow-css는 개발 중 저장할 때마다 수정된 부분이 있으면 css를 새로 만들어 준다.\n빠르게 개발하고 싶어서 클로저를 선택했지만 빨라지기까지 엄청 오랜 시간이 걸릴 것 같다. 개발 속도가 빠르다는 것은 개발 중 고려해야할 세부적인 부분들을 다 알고 있기 때문이고 클로저를 해보며 느끼는 점은 그 세부적인 부분들을 알아야 다음으로 넘어갈 수 있다는 것이다.\n첫 오픈소스 커밋 성공 # 막히는 게 있어 clojurescript 슬랙 채널에 문의 글을 남겼는데 감사하게도 라이브러리 주인이 답을 달아 주었다. tailwind alias들이 전부 구현되어 있지는 않았는데 이게 의도한 것인지 아닌지 알 수 없어서 관련해서 커밋해도 괜찮을지 여쭤보았다. shadow-css에서는 처음 시작할 때 기본 alias들을 우선 빌드하는데, 음수값을 사용할 수 없어서 그 부분만 추가해서 커밋하니 바로 받아주었다. 기쁘다 기뻐.\n"},{"id":5,"href":"/ko/posts/221101131405-%EB%A7%A4%EC%9D%BC_%ED%95%98%EB%82%98%EC%9D%98_%EC%84%A0%ED%96%89%EC%9D%84_%ED%95%A0%EC%9D%BC%EB%A1%9C_%EB%B3%B4%EB%82%B4%EC%A3%BC%EA%B8%B0-ko/","title":"매일 하나의 선행을 할일로 보내주기","section":"기록들","content":"가입하면 -\u0026gt; 하면 기분 좋아지는 선행을 투두 리스트 ( 구글 투두? ) 등 사용 중인 투두 리스트에? 할일로 보내준다. 랜덤 발송되는 선행 목록, 프로필에 달 수 있는 뱃지 추가? 많이 수행하면 프로필에 레벨 표시?\n"},{"id":6,"href":"/ko/posts/221101131003-%EC%82%AC%EC%9A%A9%EC%9E%90_%ED%9B%84%EA%B8%B0_%EA%B8%B0%ED%9A%8D_%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%97%90_%ED%86%B5%ED%95%A9%ED%95%98%EB%8A%94-ko/","title":"221101131003-사용자_후기_기획_워크플로우에_통합하는-ko","section":"기록들","content":"고객들이 원하는 게 있어 개발 요청 설문을 작성해서 보내면 깃헙이나 트렐로 등 사용 중인 할 일 관리 툴과 통합되어 투두 리스트에 추가된다. 아니면 다른 방식으로?\n"},{"id":7,"href":"/ko/posts/221101035735-clj_kondo-ko/","title":"clj-kondo","section":"기록들","content":" clj-kondo는 # 클로저를 위한 정적 코드 분석도구이다. clojure-lsp에서 내부적으로 사용하고 있다.\n문제 # 소설 연재 플랫폼 개발 일지 005에서 잘 작동하는 코드에 lsp가 unresolved symbol 에러를 띄우는 문제가 있었다.\n해결 시도 1 # 처음에는 클래스패스를 읽지 못해서 그런가 싶어서 프로젝트 .lsp 디렉터리에 다음 설정을 해보았다.\n{:project-specs [{:project-path \u0026#34;shadow-cljs.edn\u0026#34; :classpath-cmd [\u0026#34;shadow-cljs\u0026#34; \u0026#34;classpath\u0026#34;]}]} shadow-cljs.edn이 있는 곳이 프로젝트 루트이고, 클래스패스는 다음 명령으로 읽어라하고 지정했다. 하지만 clojure-lsp는 기본적으로 shadow-cljs.edn 파일이 발견되면 npx shadow-cljs classpath 명령으로 클래스패스를 읽는다고 한다. 별 의미 없는 설정이었다.\n해결 # 검색 결과 유사한 문제를 겪는 분이 있어 해당 스레드의 도움을 받았다.\nClj-kondo only expands a selected set of macros from clojure.core and some popular community libraries. For unrecognized macros you can use these configurations:\nclj-kondo는 일부 유명한 라이브러리들과 클로저 코어에 있는 매크로들만 파악할 수 있다고 한다. clj-kondo가 알지 못하는 매크로들은 다음과 같은 설정을 해주어야 한다.\n{;; https://github.com/clj-kondo/clj-kondo/blob/master/doc/linters.md#unresolved-symbol :linters {:unresolved-symbol {:exclude [render]}} ;; https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#lint-a-custom-macro-like-a-built-in-macro :lint-as {shadow.grove/defc clojure.core/defn}} 속이 시원하다.\n"},{"id":8,"href":"/ko/posts/221101020740-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_005-ko/","title":"소설 연재 플랫폼 개발 일지 005","section":"기록들","content":" 다시 shadow-grove로 # 레퍼런스가 없어서 힘들었었는데 다시 해보니 뭔가 알 것 같다. shadow-cljs를 개발한 thheller가 만들고 있는 cljs 프레임워크인데 하나 하나 설명을 읽어가면서 개척해나가는 재미가 나름 있다. 당연하게 여겼던 hot-reload도 여기서는 직접 구현해야 했다. 다행히 thheller 이 분이 Hot Reload in ClojureScript 라는 아티클을 남겨두셔서 조금 이해할 수 있었다. 나중에 꼭 번역을 해둬야겠다.\nCss 관련 배운 것 # css는 가능한 static하게 서빙하는 게 좋다고 한다. 동적으로 런타임에 css를 빌드하게 되면 그만큼 사용자에게 그 비용을 전가하게 된다.\nJvm memory 사용량 # 원래 css로 tailwind를 써보다가 빌드 훅을 잘못 짰는지 빌드 할 때마다 jvm 메모리 사용량이 40% 까지 올라가곤 했는데 다음 옵션을 shadow-cljs.edn에 명기함으로써 램을 최대 1G 까지만 사용하라고 정해줄 수 있었다.\n:jvm-opts [\u0026#34;-Xmx1G\u0026#34;] shadow-grove에는 shadow-css # tailwind를 따로 의존성에 추가하지 않아도 된다. tailwind config 파일을 따로 관리하지 않아도 되어서 너무 좋다. 메모리 제한을 둬서 그런지 몰라도 css 빌드 훅도 안정적이고 훨씬 빠르게 적용된다.\n아래는 shadow-css 리포지터리의 css dev-build 를 참고하여 작성해본 빌드 훅이다. 현재는 cljs를 js로 빌드할 때마다 전체 css 파일을 다시 쓰고 있는데 더 나은 방법은 없을까\u0026hellip;\n(ns app.css (:require [clojure.java.io :as io] [shadow.css.build :as cb])) (defonce css-ref (atom nil)) (defn generate-css [] (reset! css-ref (-\u0026gt; (cb/start) (cb/index-path (io/file \u0026#34;src\u0026#34; \u0026#34;main\u0026#34;) {}))) ;; 변경된 pulp.app 네임스페이스의 코드를 읽어 pulp.css 파일로 빌드하여 public/css/ 디렉터리에 쓴다. ;; wildcard인 별표로 pulp.app를 다 보고 있지만 css 생성만 담당하는 파일을 만들어 해당 파일이 변경될 때만 ;; css를 생성하도록 로직을 변경해봐야겠다. (let [result (-\u0026gt; @css-ref (cb/generate \u0026#39;{:pulp {:include [pulp.app*]}}) (cb/write-outputs-to (io/file \u0026#34;public\u0026#34; \u0026#34;css\u0026#34;)))] (prn \u0026#34;css generated\u0026#34;) (doseq [mod (:outputs result) {:keys [warning-type] :as warning} (:warnings mod)] (prn [:CSS (name warning-type) (dissoc warning :warning-type)])) (println))) (defn gen {:shadow.build/stage :flush} [build-state] (prn \u0026#34;generating css...\u0026#34;) (generate-css) build-state) 작성자는 fs-watcher를 추가하여 빌드 훅이 아니라 repl을 통해 따로 프로세스를 띄워두는 것 같은데 나는 아무리 해도 어떻게 하는건지 모르겠어서 그냥 빌드 훅으로 적용했다.\n해결 못한 문제 # clojure-lsp classpath를 못 읽는건지 자꾸 잘 작동하는 코드에 에러 메시지를 띄운다. shadow-cljs classpath 하면 shadow-grove가 있는 것이 확인되는데 관련 코드를 인식 못한다. unresolved symbol 어떻게 해결해야 할지 모르겠다. 그냥 lsp 끄고 써야하나. "},{"id":9,"href":"/ko/posts/221026213857-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_004-ko/","title":"소설 연재 플랫폼 개발 일지 004","section":"기록들","content":" 결과 # css 라이브러리로 garden -\u0026gt; herb -\u0026gt; tachyon 을 사용하기로 정했다. 레퍼런스 삼을만한 사이트들을 찾아봐야겠다.\n잡담 # 이맥스와 리습은 좋은 짝꿍이 맞는 것 같다. 어제 라이브 코딩으로 연주하는 영상들을 봤는데 내가 정말 하고 싶은 건 이런 쪽인 것 같다. 열심히 웹 개발 하다가 하루 정도는 supercollider, overtone, shadertone 이런 애들 써봐야겠다. 신기했던 게 supercollider를 common-lisp으로 작성할 수 있게 해주는 라이브러리를 한국 분이 작성하셨던데 엄청 멋있었다. https://www.youtube.com/watch?v=xzTH_ZqaFKI\u0026t=682s\n"},{"id":10,"href":"/ko/posts/221026204351-emacs%EC%97%90%EC%84%9C_%EC%9B%B9%ED%82%B7_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-ko/","title":"emacs에서 웹킷 브라우저 사용하기","section":"기록들","content":" 왜? # 한영 키 전환을 이맥스와 fcitx가 같이 핸들링하다 보니 불편한 점이 많이 있었다. 크롬 브라우저에서 한영키(fcitx)를 통해 한글로 전환한 후, 이맥스에 돌아오면 아무 키도 먹히지 않는다. 다시 브라우저에 돌아가서 영어로 전환해야만 했다.\n그래서 최대한 이맥스 밖을 안 나가는 쪽으로 문제를 해결해보려고 했다. eww로도 충분히 브라우징이 가능했으나 스크래치 버퍼? 미니 버퍼? 에서 보여주는 건지 모르겠으나 자꾸 q만 누르면 창이 꺼진다. 뭔가 개인 설정 파일을 수정하는 걸로 해결될 것 같았지만 다른 방법은 없는지 검색해봤다.\nxwidget-webkit # watching youtube inside emacs??? 참을 수 없지. M-x xwidget-webkit-browse-url 로 구글을 열어봤지만 your emacs was not compiled with xwidgets support 이맥스가 xwidgets를 지원하는 방식으로 컴파일되어 있지 않다고 한다.\n이맥스를 다시 빌드해야 한다. # 아치에서 이맥스 빌드하기\n결과 # 웹킷 서포트가 있으니 오그모드도 큰 글자는 크게 렌더링 된다. 이맥스가 더 이뻐진 것 같다.\n다른 문제는 # 이전에는 그냥 이맥스 켜면 빠르게 켜졌는데 이제는 엄청 느리게 켜진다. \u0026gt;\u0026gt; 다시 systemctl로 이맥스 데몬으로 띄우고 서버 클라이언트 방식으로 사용하도록 설정을 바꾸었다. 이맥스 사용하며 느끼는 점 # 좀 더 익숙해지면 이맥스에서 나가지 않아도 모든 것을 할 수 있겠다는 생각. 아직 이린이라 자꾸 나가서 터미널 키고 싶어진다.\n더 참고하면 좋은 링크 # 마크다운 라이브뷰 "},{"id":11,"href":"/ko/posts/221025170044-cider%EB%A1%9C_repl_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0-ko/","title":"cider로 repl 연결하기","section":"기록들","content":" refs # 이름공간 변경하기 clj tool로 REPL 시작하기 # 이런 deps.edn 파일이 있다고 했을 때\n{:aliases {:dev {...} :test {...}}} 다음 명령어로 aliases와 함께 REPL을 실행할 수 있다.\nclj -M:dev:test # 혹은 clj -A:dev:test Namespace 사용하기 # clojure 프로젝트는 ns(namespace)로 스코프를 분리하고 있다. repl 환경에서 (ns dev.server) 을 실행하면 해당 ns를 만들고, 그 공간으로 넘어간다. 이 때 이전 공간에서 선언했던 이름들에는 접근할 수 없다.\nuser=\u0026gt; (def x 42) #\u0026#39;user/x user=\u0026gt; x 42 user=\u0026gt; (ns server) nil server=\u0026gt; server=\u0026gt; x Syntax error compiling at (REPL:0:0). Unable to resolve symbol: x in this context server=\u0026gt; (ns user) nil user=\u0026gt; x 42 in-ns 와 ns 의 차이점 # in-ns가 ns에 비해 일을 좀 덜한다. in-ns는 기존에 있는 이름 공간으로 넘어가는 역할만 한다. 만약 그 공간이 없다면 하나 만들어서 넘어가긴 하는데 clojure.core에 있는 이름들을 가져오지 않는다. 그래서 defn 같은 클로저 코어 함수들을 사용할 수 없다.\n그리고 문법이 조금 다르다. ns로 이름 공간을 사용할 시 작은 따옴표를 앞에 붙이지 않는다. ' 는 심볼이다.\n기존에 있는 공간으로 넘어가기 # 프로젝트 내에 dev.server 라는 이름 공간이 선언되어 있다고 하자. 해당 공간에 접근하기 위해 in-ns를 사용해서 넘어가려고 했지만 새로운 공간을 선언한다.\nuser=\u0026gt; (in-ns \u0026#39;dev.server) #object[clojure.lang.Namespace 0x57dc9128 \u0026#34;dev.server\u0026#34;] dev.server=\u0026gt; dev.server=\u0026gt; (start! 6000) Syntax error compiling at (REPL:1:1). Unable to resolve symbol: start! in this context 작성되어 있는 프로그램 파일의 ns를 가져오기 위해서는 (require 'project.dev) 를 먼저 실행해줘야 한다. 그래야 해당 ns가 의존하고 있는 파일들과 해당 스코프의 이름들을 다 가져온다. 그 후에 (in-ns 'project.dev) 로 해당 이름공간으로 들어가면 그 공간에 작성되어 있는 함수들에 접근할 수 있다.\nCIDER로 REPL을 실행하여 Namespace 사용하기 # ref # practicalli 프로젝트 설정 안내\n.dir-locals.el # 프로젝트 루트에 .dir-locals.el 파일을 만든다. 이맥스가 해당 파일이 있는 프로젝트 내부의 파일을 실행할 때 여기 적힌 설정대로 구동된다. 바보같이 파일 이름을 .dir-local.el로 써서 왜 안되는지 한참 헤맸다.\nclojure setting # 클로저 모드일 때 cider 설정 변수에 접근해서 바꿔준다. 앞으로 cider로 repl을 실행할 때마다 빌드 툴로 clj 를 사용하고, 함께 실행할 alias들로 dev와 test를 지정한다. 그럼 맨 위의 cli로 실행했을 때와 같이 edn 파일에 적힌 dev, test를 함께 실행해준다.\n((clojure-mode . ((cider-preferred-build-tool . clojure-cli) (cider-clojure-cli-aliases . \u0026#34;:dev:test\u0026#34;)))) CIDER로 코드 불러오기 # require 단계를 단축키로 해결할 수 있다. C-c C-k (cider-load-buffer)로 현재 버퍼의 코드를 불러온다. 그 후에는 해당 스코프의 s-표현식들을 실행할 수 있다.\n"},{"id":12,"href":"/ko/posts/221025110630-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_003-ko/","title":"소설 연재 플랫폼 개발 일지 003","section":"기록들","content":" 목표 # 타 연재 플랫폼 웹 클라이언트에서 서버 데이터 어떤 형식으로 가져오는지 확인할 것 그 형식에 맞춰 API 변경하기 lispy 사용해서 repl 연결하기, repl 활용하는 방법들 익숙해지기 garden으로 css 적용하기 i18n 한국어 영어까지 하기, 접속자 ip 위치에 따라 다른 언어 제공하기 과정 # 후기 # 이 날은 기록을 안했다. 반성. 하루 목표를 투두 리스트로 작성한 것은 잘했다. 다시 시도해보자.\n"},{"id":13,"href":"/ko/posts/221024121907-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_002-ko/","title":"소설 연재 플랫폼 개발 일지 002","section":"기록들","content":" 목표 # 연재 플랫폼 기능 정의하기 realworld앱 분석해서 불필요한 부분 제거하기 과정 # 소설 연재 플랫폼 개발 일지 001에서 찾은 리얼월드 앱 서버, 클라이언트가 서로 호환되는 것을 확인하고 로컬에서 돌려보았다. 너무 잘 된다. 다만 polylith와 edn 파일로 클로저 프로젝트를 어떻게 시작하고 repl 연결을 이맥스에서 어떻게 하는건지 잘 모르겠어서 좀 헤멨다. CIDER만으로 하면 잘 되는데 lispy 플러그인으로 연결하니 잘 안된다. e 를 눌렀을 때 jack-in이 아니라 connect로 연결하는 방법은 없을까\n결론 # CRUD 잘 되니 CSS 고치고 i18n 영어까지만 한 다음에 클라우드 플레어에 올려보자.\n"},{"id":14,"href":"/ko/posts/221023135710-%EC%86%8C%EC%84%A4_%EC%97%B0%EC%9E%AC_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EA%B0%9C%EB%B0%9C_%EC%9D%BC%EC%A7%80_001-ko/","title":"소설 연재 플랫폼 개발 일지 001","section":"기록들","content":" 목표 # shadow-cljs, shadow-grove 사용해서 dummy data 메인 페이지 띄우기. 과정 # shadow-grove는 어떻게 써야하는지 이해가 안된다. 예제 앱에서 모델을 참고하고 있는데 그 모델이 어디에 정의되어 있는지 찾을 수가 없었다. realworld 앱 예제들 중에서 re-frame을 사용한 프로젝트를 발견했다. 서버 또한 클로저로 작성된 것을 찾을 수 있었다. re-frame이 SPA 프레임워크라 둘이 같이 쓰일 수 있을지는 모르겠지만 좋은 레퍼런스를 찾아 기분이 좋다.\n결론 # rum을 사용해보고 싶었지만 자유도는 아직 독인 것 같다. re-frame을 쓰면서 이벤트 드리븐, 데이터 드리븐 사고방식에 익숙해져 봐야겠다.\nScale changes everything. Frameworks are just pesky overhead at small scale - measure them instead by how they help you tame the complexity of bigger apps, and in this regard re-frame has worked out well. Some have been effusive in their praise.\n큰 규모의 앱을 만들어보고 싶다. css는 garden을 사용하고 db는 re-posh와 datsync를 사용해보고 싶다.\n"},{"id":15,"href":"/ko/posts/221020193116-emacs%EC%97%90%EC%84%9C_gmail_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-ko/","title":"Emacs에서 Gmail 사용하기","section":"기록들","content":" 목표 # Doom emacs에서 Gmail을 수발신 하기 위해 필요한 설정들과 그 과정에서 배운 것들을 기록하기 위함.\n이맥스내에서 필요한 설정 # ~/.doom.d/init.el 파일 # (doom! ;;... :email ;; 이 부분 주석 해제 (mu4e +org +gmail)) mu4e란 # mu for emacs 라는 뜻의 이름인 듯 하다. 위 mu4e 변수 위에 K 키를 누르면 Readme문서를 확인할 수 있다.\nmu는 maildir-utils 의 약자이다. maildir 포맷 디렉터리 내의 이메일 메시지들을 다루는 도구 모음이다. 커맨드라인에서 메시지들을 색인, 검색, 추가, 삭제, 확인할 수 있다. mu4e가 mu에 의존하니 우선 mu를 OS 패키지 매니저에서 설치하거나 리포지터리에서 클론해 직접 빌드해주어야 한다.\nmu 설치 # # Arch yay -S mu # MacOS brew install mu # Debian/Ubuntu apt-get install maildir-utils mu4e mu를 설치하고 나면 man mu 혹은 man mu-easy 로 매뉴얼을 확인할 수 있다.\nisync 설치 # mail 서버의 maildir와 로컬 maildir를 동기화하기 위해서는 isync (mbsync) 혹은 offlineimap을 사용해야 한다.\nyay -S isync 그 후 유저 홈 디렉터리에 설정 파일을 작성해주어야 한다. 아치 위키의 설명대로 설정해주었으나 잘 되지 않아서 검색해보니 /usr/share/doc/isync/examples/mbsyncrc.sample 위치에 공식 설정 레퍼런스 파일이 있었다. 하지만 공식 레퍼런스에 설정되어 있는 RequireSSL 옵션은 deprecated 되었고, SSLType 옵션을 사용하는 것이 맞다고 한다.\n다른 이메일 클라이언트에서 Gmail 확인하기 구글 문서를 확인하고 최종적으로 다음과 같이 설정해주었다.\n~/.mbsyncrc 파일 # # IMAP 접속 계정 정보를 여기에 설정한다. IMAPAccount gmail Host imap.gmail.com User YOUR_ID # 비밀번호는 PassCmd에 설정한 gpg 명령어로 .mailpass.gpg에 저장한 암호를 복호화하여 사용한다. PassCmd \u0026#34;gpg2 -q --for-your-eyes-only --no-tty -d ~/.mailpass.gpg\u0026#34; Port 993 SSLType IMAPS # The following line should work. If you get certificate errors, uncomment the two following lines and read the \u0026#34;Troubleshooting\u0026#34; section. CertificateFile /etc/ssl/certs/ca-certificates.crt #CertificateFile ~/.cert/imap.gmail.com.pem #CertificateFile ~/.cert/Equifax_Secure_CA.pem # 리모트 저장소 계정에 위에서 작성한 계정 이름을 적는다. IMAPStore gmail-remote Account gmail # 동기화할 로컬 저장소 정보를 작성한다. MaildirStore gmail-local SubFolders Verbatim Path ~/mailbox/Gmail/ Inbox ~/mailbox/Gmail/Inbox Channel gmail Far :gmail-remote: Near :gmail-local: # Exclude everything under the internal [Gmail] folder, except the interesting folders Patterns * ![Gmail]* \u0026#34;[Gmail]/Sent Mail\u0026#34; \u0026#34;[Gmail]/Starred\u0026#34; \u0026#34;[Gmail]/All Mail\u0026#34; # Or include everything #Patterns * # Automatically create missing mailboxes, both locally and on the server Create Both # Sync the movement of messages between folders and deletions, add after making sure the sync works Expunge Both # Save the synchronization state files in the relevant directory SyncState * gmail IMAP 사용 설정 # gmail 페이지 우측 상단 톱니바퀴 버튼을 누르면 모든 설정 보기 버튼이 있다.\nFigure 1: gmail IMAP 설정\n앱 비밀번호 설정 # 구글 계정관리 페이지 보안 탭으로 들어가면 앱 비밀번호를 설정할 수 있다. 여기서 말하는 앱이란 앞서 설정한 mbsync를 의미하는 것 같다. mbsync가 구글 서비스에 접속하려할 때 사용하는 비밀번호인 것이다. 따라서 여기서 설정하는 비밀번호를 gpg를 사용해 로컬에 저장해두면 된다.\nFigure 2: google app password 설정\ngpg 사용법 # 더 상세한 설명은 기계인간님 블로그에서 확인할 수 있다.\n# gpg로 키를 생성한다. gpg --generate-key # 구글 계정설정 보안탭에서 설정한 앱 비밀번호를 다음 파일에 작성한다. echo \u0026#34;app-password\u0026#34; \u0026gt;\u0026gt; ~/.mailpass # gpg 해당 비밀번호를 암호화한다. 그러면 ~/.mailpass.gpg 파일이 생긴다. gpg -e ~/.mailpass mu maildir init # 우선 위에서 설정한 로컬 MaildirStore 구조에 맞게 디렉터리를 생성해준다.\nmkdir -p ~/mailbox/Gmail mu init 해준다.\nmu init --maildir=\u0026#34;~/mailbox/Gmail\u0026#34; --my-address=\u0026#34;YOUR-ID@gmail.com\u0026#34; # 문제 없다면 다음과 같은 결과가 나온다. +-------------------+---------------------------------+ | maildir | /home/user/mailbox/Gmail | +-------------------+---------------------------------+ | database-path | /home/user/.cache/mu/xapian | +-------------------+---------------------------------+ | schema-version | 465 | +-------------------+---------------------------------+ | max-message-size | 100000000 | +-------------------+---------------------------------+ | batch-size | 250000 | +-------------------+---------------------------------+ | created | Thu 20 Oct 2022 09:13:33 PM KST | +-------------------+---------------------------------+ | personal-address | YOUR-ID@gmail.com | +-------------------+---------------------------------+ | messages in store | 0 | +-------------------+---------------------------------+ | last-change | never | +-------------------+---------------------------------+ | last-index | never | +-------------------+---------------------------------+ 이메일 동기화 # # 위 mbsync 설정 파일에 작성한 Channel 이름으로 명령어를 실행하면 된다. # 본인 계정의 메일박스들이 제대로 출력되는지 -l 옵션으로 확인해본다. mbsync -l gmail # 이상없이 출력된다면 -L 옵션으로 pull 해올 수 있다. mbsync -L gmail 이맥스에서 gmail 사용해보기 # 이제 SPC o m 로 mu4e 를 열고 u 눌러주면 알아서 메일을 가져와준다.\nFigure 3: mu4e test\n"},{"id":16,"href":"/ko/posts/221018205036-%EC%BD%94%EB%93%9C%EB%A5%BC_%EC%9E%98_%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0_%EC%9C%84%ED%95%B4%EC%84%9C%EB%8A%94-ko/","title":"코드를 잘 작성하기 위해서는","section":"기록들","content":" 내 고민에 대한 고마운 분의 조언 # 이전에 작성한 코드가 읽기 힘들어서 고민이다. # 코드(를 포함한 모든 형식의 글)은 후에 읽어야 할 사람을 생각하며 써야 한다. 경력이 쌓일수록 이런 능력이 생겨야 하고, 생길 것이다. \u0026ldquo;프로그래머의 뇌\u0026quot;라는 책을 읽어보길 권하셨다. 코드를 잘 작성하는 능력보다 코드를 잘 읽는 능력이 상대적으로 과소평가 되어있다. 코드를 잘 읽는 연습을 해보자. 앞으로 어떤 기술 스택을 주로 공부해야 할지 잘 모르겠다. # 앞으로 웹베이스(브라우저와 Js런타임)의 에코 시스템이 더욱 커질 것이라고 생각한다. "},{"id":17,"href":"/ko/posts/221018195600-youtube%EB%8A%94_%EB%B9%84%EB%94%94%EC%98%A4%EB%A5%BC_%EC%96%B4%EB%96%BB%EA%B2%8C_%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94%EA%B0%80-ko/","title":"youtube는 비디오를 어떻게 저장하는가","section":"기록들","content":"원문\n요약 # 서버는 마이크로 서비스로 python, c, c++, java, go로 작성되어 있다. DB는 Vitess 로 돌리는 MySql 사용. Memcache 는 Caching에 사용. Zookeeper 는 node co-ordination. node co-ordination이 뭐지?\n데이터 흐름 # Figure 1: 유튜브 아키텍쳐\n자주 요청되는 비디오는 CDN server에 두고 별로 인기 없는 비디오는 DB에서 직접 가져온다.\n시작점 # 유튜브는 2005년 시작했고 2006년 11월 구글에 인수되었다. 구글에 인수되기 전에는 2명의 시스템 관리자, 2명의 소프트웨어 설계자, 2명의 기능 개발자, 2명의 네트워크 엔지니어, 1명의 DBA 로 구성되어 있었다. youtube도 당연하지만 하나의 DB 인스턴스에서 출발했다. 많아지는 요청에 따라 수평적으로 RDB를 확장해야할 필요를 느낌. 주인-노예 복제 전략 # DB를 여러 인스턴스로 복제함 원본 DB에서만 입력(쓰기)을 받는다. ( 원본 DB를 master라고 부름 ) 원본 DB가 복제된 DB로 입력된 데이터를 넣어준다. ( 복제 DB를 replica라고 부름) 출력(읽기)는 복제된 DB와 원본 DB 모두에서 수행된다. 이 구조에는 문제가 있는데 master와 replica가 기록하고 있는 데이터가 다른 시점이 존재하게 된다는 것이다. master에 입력된 데이터가 replica에 업데이트 되기 전에 플레이 가능한 비디오 목록 요청이 들어오면 업데이트 이전의 데이터 목록을 유저에게 전송하게 된다. 하지만 유저는 별로 신경쓰지 않는다. 선택한 비디오가 제대로 틀어지기만 하면 되는것이다. 시간이 지나면 master와 replica 사이의 데이터 차이는 결국 같아진다.\n하지만 이 master-slave replication 전략에도 한계가 있는 것 같다.\n앱이 대박나서 입소문을 타고 사용자들이 급증한다. 너도 나도 자기 동영상을 업로드하기 시작한다. 그러면 하나의 master DB로는 쓰기 작업의 부하를 혼자 감당하지 못하게 될 것이다. 그럼 이제 어떻게 해야할까?\nSharding (조각내기) # 샤딩이란\n다음 전략은 DB를 쪼개는 것이다. # Sharding은 관계형 DB를 확장하는 여러 방법 중 하나이다.\n앞서 설명한 master-slave replication외에 master-master replication, federation \u0026amp; de-normalization 등이 있다 고 하는데 나머지는 머리 아프니 다음에 알아보자. 데이터들을 수평적으로 여러 머신에 쪼개서 보관하고 관리하자. 그렇게 하면 DB가 받는 부하가 나눠진다.\n예를 들면 User 데이터만 다루는 서버와 Payment 데이터만 다루는 서버를 나누어 API를 통해 데이터를 교환하게 만드는 식이다. 하지만 서버를 분산한다는 것은 쉬운 일이 아니다. 원하는 데이터를 추출하기 위해서는 쪼개진 DB 서버끼리 네트워크를 통해 소통해야 함으로 지연되는 시간이 생겨 속도가 저하된다. 또한 복잡해진 구조 때문에 관리도 어려워진다.\n그럼에도 불구하고 서비스가 성장하게 되면 해야하는 일이다. 기하급수적으로 높아지는 QPS(query per second)를 하나의 DB, 하나의 서버가 물리적으로 감당할 수가 없다. DB 쪼개기를 성공적으로 마쳤다면 이제 쓰기 작업을 여러 대의 서버 컴퓨터에서 나눠서 처리할 수 있게 되었다.\n너무 고맙게도 앱 사용자가 더 늘어난다. 너무 많은 양의 데이터가 한 번에 마구 쏟아진다. 근데 나눠놓은 서버 중에 하나가 열이 받았는지 내가 뭘 잘못했는지 자꾸 꺼진다. 나도 열이 받는다. 어떻게 해야할까?\n재난 관리 # 세상에는 예측 못할 일들이 너무 많다. 갑자기 지진이 나서 서버 컴퓨터가 다 고장날 수도 있고 중국 산업 스파이가 컴퓨터를 통째로 들고 튈수도 있다. 하지만 대비할 수 있다.\n전 세계에 여러 대의 데이터 센터를 두면 된다. 그리고 데이터들을 동기화한다. 전 세계에 데이터 센터를 나눠두게 되면 사용자 요청에 좀 더 빠르게 대응할 수 있다는 점이 또 다른 이점이다. 서울에서 요청된 데이터는 서울에 위치한 데이터 센터에서 보내주고 유럽에서 요청된 데이터는 유럽의 데이터 센터에서 보내준다.\n최적화되지 않은 full table scan query들은 종종 모든 데이터베이스를 죽이기도 한다. 나쁜 쿼리들로부터 보호되어야 한다. 모든 서버들은 효율적인 서비스를 보장하기 위해 추적되어야 한다. 이제 인프라가 너무 복잡해졌다. 머리 아프다. 개발자들은 이 모든 복잡성을 추상화한 시스템이 필요하다.\n최소한의 노력으로 관리하고, 확장도 더 쉽게 하고 싶다. 이제 어떻게 할까?\nVitess # Vitess\nSqlDB의 수평적 확장이 가능하게 하는 쿠버네티스 기반 DB 관리 시스템 # 유튜브, 슬랙, 깃헙, 스퀘어 등에서 사용된다. Go로 작성됨.\nVitess는 개발자가 직접 DB 쪼개기 로직(만약 payment DB의 부하가 50% 이상이면 하나의 payment DB 서버를 더 생성해줘)를 직접 앱에 작성하지 않아도 된다. Sharding 기능이 내장되어 있다. Fail-Over(장애 발생시 예비 시스템 가동)와 Backup도 자동으로 수행한다. 또한 해당 자원에 집중적인 쿼리로 재작성해주고 데이터를 캐싱해주는 등의 방식으로 DB 성능도 높여준다.\nRDB의 ACID, 일관성을 가지는 동시에 noSQL처럼 쉽게 수평 확장을 이루고 싶다면 Vitess가 필요하다.\n클라우드에 배포하기 # vitess는 클라우드 환경이 기본이다. 클라우드 네이티브 분산 데이터베이스. 요즘 컴퓨팅 시대에는 모든 규모 있는 서비스들은 많은 언어로 개발되고 있다. 서비스의 많은 유즈 케이스를 잘 다루기 위해서는 관계형과 NoSQL 모두 필요하기 때문이다.\nCDN # 유튜브는 구글의 글로벌 네트워크를 이용해서 콘텐츠 전송에 낮은 지연시간, 낮은 비용을 이룬다. 멀리 돌아왔다. 이제 어떻게 유튜브가 비디오를 저장하는지! Storage 얘기를 한다.\nData Storage - 유튜브는 미친 데이터 용량을 어떻게 저장하는가! # 구글 파일 시스템(GFS, Google File System)\n비디오들은 웨어하우스만한 크기의 구글 데이터센터 하드드라이브들에 저장된다. 데이터는 google file system과 BigTable로 관리된다.\nGFS(google file system) # 많은 양의 데이터를 분산 환경에서 관리하기 위해 구글이 개발한 분산 파일 시스템\nBigTable # 수천 대의 기계에 분산된 patabyte급의 데이터를 처리하기 위해 구글 파일 시스템 위에 구축된 저지연 분산 데이터 저장 시스템.\n비디오는 HDD에 저장된다. 관계, 메타 데이터, 사용자 선호 정보, 프로필 정보, 계정 설정, 비디오를 가져오기 위해 필요한 관계 정보 등은 MySQL에 저장된다.\n"},{"id":18,"href":"/ko/posts/221018174449-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85_%EC%8A%A4%EC%BF%A8_%ED%9A%8C%EA%B3%A0-ko/","title":"스타트업 스쿨 회고","section":"기록들","content":" 멋있는 사람들이 다 모인 곳. # 1년이나 지났지만 그 장소, 그 사람들의 진지하고 열정적인 바이브가 그립다. 다들 스타트업을 하려고 모인 사람들이다 보니 모두 행동력이 좋았다. 나는 굉장히 사교적이지 못한 성격인데 운이 좋게도 좋은 사람들이 다가와줘서 많이 배울 수 있었다. 뭔가 나 자신이 상대적으로 너무 부족한 느낌이 들어 나를 더 크게 포장하곤 했었는데 지금 돌이켜보니 너무 부끄럽다. 겸손하고도 당당할 수 있어야 한다.\n배운 점. # 멘탈과 관련해서 # 내가 느낀 것은 아이디어 자체는 정작 크게 중요하지 않다는 것이었다. 그 사람, 구성원이 얼마나 진지한지, 구현의 의지가 강한지가 중요하다는 것이다. 하나 더 달자면, 아니라고 판단되면 그 좋은 생각을 죽일 수 있는가. 투자자의 입장에서만이 아니라, 나 자신이 나를 봤을 때. 나는 냉정하지도 못했고, 순진했고, 진지하지도 못했다.\n투자와 관련해서 # 이 과정 전에 나는 다음과 같이 생각했다.\n좋은 아이디어가 있다면 -\u0026gt; 사업계획서를 작성하여 -\u0026gt; 투자를 받으러 다닌다 -\u0026gt; 투자금으로 구현한다. -\u0026gt; 사업화한다. 이후에는 조금 달라진 것이\n좋은 아이디어가 있다면 -\u0026gt; 구현한다 -\u0026gt; 사람들이 사용한다면 -\u0026gt; 사업계획서를 작성하고 -\u0026gt; \u0026hellip; -\u0026gt; 사업화한다.~ 사람마다 다른 방식으로 접근하겠지만 나에게는 시간이 걸려도 이게 맞는 순서인 것 같다.\n개발과 관련해서 # 작은 앱의 개발 과정을 처음부터 끝까지 계획하고 기술 요구사항에 맞는 대안들을 조사해 보면서 많은 것을 배웠다.\nAWS가 아닌 Firebase를 배포 환경, 백엔드로 정한 이유는 구글의 프리티어 정책이 더 실패 시에 안전해보였고, 앞으로 사업화가 되더라도 앱 서비스 스타트업에 대한 지원 사업이 활발해보였다. AWS도 동일한 지원 정책이 있었던 것으로 기억하지만 동일하다면 플레이스토어를 운영하는 구글을 선택하지 않을 이유가 없어보였다. + 기술 문서, 콘솔 인터페이스가 더 배우기 쉬웠다.\n사용자가 많아지는 경우 AWS가 더 비용적으로 효율적이라고 하지만 그건 그 때가서 마이그레이션하면 될 것으로 판단했다. 사용자가 많은 경우 투자 유치도 쉬워질 것이고, 돈이 있다면 사람을 구할 수 있다. 비용 효율성은 그때 가서 따져야 한다고 생각했다. 당장은 빠른 구현이 최우선이었다.\n그리고 가장 큰 이유, 구현하려한 비디오 SNS 서비스는 사용자 컨텐츠 검열이 큰 숙제였는데 구글에서 제공되는 머신러닝 API를 사용하면 좋겠다고 생각했다. AWS도 동일한 서비스를 제공하지만 당시 인공지능은 구글이 더 낫다는 글들을 많이 보아서 결국 구글로 결정하게 되었다.\n아쉬운 점 # 나 자신에게 정말 많은 기대와 실망을 했던 기간이었다. 나의 능력을 제대로 파악하지 못한 탓에 무리한 계획을 세웠고, 다트와 플러터를 써보고 싶은 욕심과, 서비스를 출시한다면 앱을 만드는 것이 더 낫다는 일차원적인 판단으로 커리큘럼에서 가르쳐주는 기술 스택을 사용하지 않았다.\n그 때문에 개발에 상대적으로 경험이 적었던 팀원들의 학습 의욕을 저하시켰고, 결과적으로 좋은 사람들에게 피해를 주었다. 충분히 소통을 했다고 생각했지만 소통이 아니었다. 결국 개발에 관한 부분은 아주 조금이나마 더 알고 있는 내 판단을 존중해주었었고, 나는 그 때 내가 아니라 팀원들의 입장에서 생각했어야 했다. 내가 그 사람들의 학습 기회를 박탈한 것이나 다름 없었다.\n다시 이런 기회가 온다면 나의 욕심은 반드시 없앨 것이다. 정말 후회된다.\n"},{"id":19,"href":"/ko/posts/221018165518-42%EC%84%9C%EC%9A%B8_%ED%94%BC%EC%8B%A0_%ED%9A%8C%EA%B3%A0-ko/","title":"42서울 피신 회고","section":"기록들","content":" C가 왜 중요한지 느낄 수 있었다. # 자바스크립트로 처음 코드를 배웠기 때문에 동적이고, 유연한 프로토타입 기반의 언어를 기준으로 프로그램을 생각하고 있었다. 그냥 코드를 작성하면 언어가, 컴파일러가 알아서 다 해주니까, 따로 신경써본 적이 없었고, 그러다보니 그 블랙박스 내의 동작은 내가 상상해볼 수 없는 영역이었다.\n\u0026ldquo;잘 작성되었고, 빠르고 인기가 많은\u0026rdquo; 라이브러리들을 찾아 거기서 제공해주는 API를 매뉴얼대로 작성하는 것이 전부였다. 뭔가 부족하다고 생각이 들었고 이대로 괜찮을지에 대한 불안감은 늘 있었지만 정작 나 스스로 블랙박스를 열어볼 용기와 인내는 없었던 것 같다.\n운이 좋게도 피신 과정을 진행하며 C의 Array를 다뤄보았는데, 그 과정에서 언어가 컴퓨터에 어떤 방식으로 자료를 입출력하는지 들여다볼 수 있었다. 피신 전에는 부끄럽게도 Array가 List와 같은 것을 말하는 다른 단어인 줄 알고 있었다.\n내가 작성한 코드를 남에게 잘 설명할 수 있다는 것. # 42 과정은 컴퓨터 과학 로드맵을 과제로서 제시해주고 동료 평가라는 방식으로 과제를 해결해나간다. 과제를 해결하면, 동료가 옆 자리에 와서 코드 리뷰를 해주고, 점수를 부여해준다. 작성한 코드를 잘 설명하지 못하면, 평가자는 본인이 쓴 코드가 아니라고 판단하고 실패를 줄 수도 있다.\n나는 그 동안 거의 혼자서 코드를 작성했었고 다른 사람에게 내 코드를 설명하고, 평가받을 일이 잘 없었다. 그러다 보니 처음에는 조금 어색하고 힘들었지만 진행되며 이런 방식이 내 학습에 얼마나 큰 도움이 되는지 몸소 실감할 수 있었다.\n내가 풀고있는 문제를 본인의 문제처럼 고민해주고 해결책을 제시해주시는 고마운 분도 있었고, 내가 모르고 있던 지식을 설명해주어 부족한 부분을 채워주시는 분도 있었다. 그런 식으로 동료가 전달해주는 지식도 좋았지만, 정말 좋았던 것은 머릿 속으로만 굴리던 코드 흐름을 입 밖으로 내면서 코드와 내 복잡한 머릿 속이 정돈되는 느낌을 받았다.\n설명할 수 없으면 알고 있다고 할 수 없다.\n그래서 앞으로 코드를 작성하고 다른 사람에게 말로서 설명할 기회가 잘 없다고 하더라도, 배운 것을 글로써 출력하는 습관을 들여야겠다고 느꼈다.\n세상에 잘하는 사람들이 이렇게 많다. # 전공자는 잘하고, 비전공자는 못한다고 생각하진 않는다. 내가 비전공자이기 때문에 못한다는 변명을 나도 모르게 하게 될 수 있기 때문이다.\n동료 평가를 다니며 느낀 것은 잘하는 사람들이 정말 많다는 것이었다. 설명을 들으며 이 사람은 머리가 정말 좋구나, 이 사람은 엄청 성실하구나, 진지하게 공부하고 있구나. 그런 생각을 하며 나 자신이 많이 초라하게 느껴질 때도 있었다.\n지금 잘하진 않더라도 앞으로가 기대되는 분들도 많았다. 점수로 본 과정의 당락이 결정되는데도 진도를 그다지 신경쓰지 않고 잘 모르는 것은 깊이 있게 알고 넘어가려는 자세를 가진 분을 보면 앞으로 엄청 잘하게 되실 것 같다는 생각이 들었다.\n아쉬웠던 점 # 과정에 대해 아쉬운 점은 없지만, 코로나에 걸려서 너무 아쉬웠다. 더 많이 배우고, 더 많은 사람들과 얘기를 나눠보고, 더 재밌을 수 있었을텐데.\n"},{"id":20,"href":"/ko/posts/221018160725-pandoc%EC%9C%BC%EB%A1%9C_md%ED%8C%8C%EC%9D%BC_pdf%EB%A1%9C_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-ko/","title":"pandoc으로 md파일 pdf로 변환하기","section":"기록들","content":" 패키지 매니저로 pandoc, wkhtmltopdf 를 설치한다.\nyay pandoc yay wkhtmltopdf css 파일을 같은 디렉터리에 위치시킨다.\nwget https://gist.githubusercontent.com/dashed/6714393/raw/ae966d9d0806eb1e24462d88082a0264438adc50/github-pandoc.css css를 적용한 html문서를 만들고, pdf로 출력한다.\npandoc -t html5 --metadata pagetitle=\u0026#34;resume.md\u0026#34; --css=github-pandoc.css resume.md -o res.pdf 상세한 설명은 스택 오버플로우에\u0026hellip;\n"},{"id":21,"href":"/ko/posts/221018112544-%EC%8A%A4%ED%83%9D_stack-ko/","title":"스택 (Stack)","section":"기록들","content":"스택은 자료를 쌓아올리는 방식으로 저장한다. 책을 쌓아둔 것과 같다. 5권의 책을 쌓아뒀을 때, 첫 번째 책을 꺼내보려면 그 책 위의 네 권을 먼저 들어올려야 한다. 이러한 특징을 FILO(First In Last Out), LIFO(Last In First Out). 처음 들어온 게 마지막에 나간다고 줄여 말한다.\n스택은 추상적 자료 구조이고, 이를 구체적으로 어떻게 구현할지는 구현자 마음대로이다.\n"},{"id":22,"href":"/ko/posts/221017200019-%EC%B6%94%EC%83%81%EC%A0%81_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0-ko/","title":"추상적 자료 구조","section":"기록들","content":"추상 자료형이 말 그대로 자료의 형식만을 정의하는 가장 높은 단계의 추상화라면,\n추상적 자료구조는 해당 자료형을 구체적으로 구현하기 위한 조건들도 함께 정의한다.\n\u0026ldquo;스택(stack)이라는 자료형(data type)의 입출력을 위한 방법에는 push와 pop이 있고, 이 연산들은 O(1)만에 이뤄져야 한다.\u0026quot;\n고 정의된 것이 있다면 이것을 추상적 자료구조라고 말하며, 이를 구현한 것을 구체적 자료구조라고 말한다.\n이렇게 위키피디아 한글 문서에서는 설명하고 있으나 영문판에서는 \u0026lsquo;추상 자료구조\u0026rsquo;와 \u0026lsquo;추상 자료형\u0026rsquo;의 정의 간에 특별한 구분을 두고 있지는 않는 것 같다. 추상 자료형과 자료구조의 차이 정도만 인식하고 있으면 될 것 같다.\n자료구조를 어떻게 정의하여 내부적으로 어떻게 구현했는가는 작성자에게 달려있기에 프로그래밍 언어에 따라 다르다. 예를 들어 스택 (Stack)은 리스트로도 구현할 수 있고 배열 (Array)로도 구현할 수 있다.\n"},{"id":23,"href":"/ko/posts/221017194720-%EC%B6%94%EC%83%81_%EC%9E%90%EB%A3%8C%ED%98%95-ko/","title":"추상 자료형","section":"기록들","content":" 추상 자료형이란 # 추상 자료형은(Abstract Data Type, ADT)는 자료의 형태와 그와 관계된 연산을 수학적으로만 정의한 것이다. 해당 자료형이 내부적으로 어떤 방식으로 구현되는지는 관심이 없다. \u0026lsquo;형\u0026rsquo;과 \u0026lsquo;Type\u0026rsquo;, \u0026lsquo;자료\u0026rsquo;와 \u0026lsquo;Data\u0026rsquo;가 동일한 뜻인 것을 가끔 인지하지 못할 때가 있다.\n정수는 추상 자료형(ADT)이다. \u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip;의 값으로 정의되며, 연산은 더하기, 빼기, 곱하기, 나누기가 가능하고, 대소 비교 등도 가능하다.\n추상적 자료형은 구현 방법을 명시하고 있지 않다는 점에서 자료 구조와 다르다. 비슷한 개념의 추상적 자료 구조는 각 연산의 시간 복잡도를 명기하고 있지만 추상적 자료형에서는 이것조차 명기하지 않는다.\n추상 자료형의 정의 # 어떻게 정의되어야 하는지에 대한 표준화된 약속은 없다. 넓게 나눠보면 \u0026ldquo;명령적\u0026rdquo;(혹은 \u0026ldquo;절차적\u0026rdquo;), \u0026ldquo;기능적\u0026rdquo;(혹은 \u0026ldquo;공리적\u0026rdquo;)인 정의 방식이 있다.\n"},{"id":24,"href":"/ko/posts/221017180001-array-ko/","title":"배열 (Array)","section":"기록들","content":"배열은 연속적인 자료의 나열이다. 배열 내에는 동일한 형(type)의 자료가 나열되어야 한다. 보통의 프로그래밍 언어에서 인덱스는 0부터 시작한다. 루아는 특이하게 1부터 시작한다.\nC에서는 선언 시에 배열로 사용될 메모리 주소의 범위를 정적으로 할당한다. 반면 Javascript에서의 배열은 동적으로 할당되며, 메모리 주소의 연속일 뿐인 C와 다르게 다양한 메서드를 포함하고 있는 객체로 구현되어 있다. 내부 작동은 브라우저의 엔진마다 다를 수 있다고 한다.\nconst arr = [1, 2, 3]; arr[1]; \u0026gt; 2 arr[\u0026#34;1\u0026#34;]; \u0026gt; 2 인덱스는 특이하게 \u0026ldquo;1\u0026quot;로도 1로도 접근 가능한데 내부적으로 toString() 메소드를 호출하기 때문이라고 한다.\n"},{"id":25,"href":"/ko/posts/221017175656-data_structure-ko/","title":"자료구조","section":"기록들","content":"자료구조란 추상 자료형을 구현한 것. 자료(데이터)의 모임, 자료간의 관계, 자료의 입출력 방식.\n왜 자료구조를 알아야 할까 # 주어진 문제를 해결할 때 자료구조를 선택하고 나면 어떤 알고리즘을 사용할지 명확해진다. 구현의 난이도, 결과물의 성능이 자료구조에 크게 의존한다.\n자료구조의 5가지 필수 구성 요소 # 참조 링크\n어떻게 접근 할 것인가. 어떻게 입력 할 것인가. 어떻게 삭제 할 것인가. 어떻게 탐색 할 것인가. 어떻게 정렬 할 것인가. 자료구조 선택 방법 # 자료구조의 분류 # 자료구조는 추상적인 구조인지, 자료간의 관계가 선형(1:1)적인지 비선형적인지 등으로 분류 되어진다.\n추상적 자료 구조 # 스택 (Stack) # 큐 # 트리 # 그래프 # 선형 자료 구조 # 배열(Array) # 리스트(List / Sequence) # "},{"id":26,"href":"/ko/resume/","title":"이력서","section":"소개","content":" 이력서 # pdf 버전\n박기둥 # 그림 그리길 좋아하다 무언가 작동하는 것을 만드는 것을 좋아하게 되었습니다.\n재밌고 새로운 것을 만들어 보고 싶다는 생각으로 프로그래밍을 시작했습니다.\n목적을 이루기 위함보다 그 과정이 즐거워서 작업을 하는 사람이 되고자 합니다.\n개인정보 # 연락처 : 이메일 공부 기록 : 블로그 코드 저장소 : 깃허브 경험 # 직무 # 기간 회사 담당 개발 스택 2021 01 - 08 나무소프트 프론트엔드 개발 Js/React, Go + Docker + AWS 나무소프트에서의 경험\n기업을 대상으로한 보안 스토리지 서비스를 운영하는 회사에서 웹 프론트엔드 개발을 담당했습니다.\n기존의 코드베이스에서는 전역 상태관리로 Redux를 사용했는데 상품 소개와 가입, 인증만을 담당하던 규모가 작은 클라이언트였고, 기능 추가의 여지도 없었기 때문에 Context API를 사용하여 불필요한 코드 복잡도를 낮추었습니다.\n기여한 다른 코드베이스로는 가입한 사용자의 스토리지 콘솔 클라이언트가 있습니다. 여기서는 서버와 클라이언트 데이터의 동기화가 제때 이뤄지지 않는 문제가 있었는데 React query 라이브러리를 도입하여 사용자가 최신의 데이터를 볼 수 있도록 하였습니다.\n중간에 가입 과정의 유저 플로우가 변경되어 서버 API를 수정해야 할 일이 있었는데 사내에서 다른 프로젝트도 병행하던 시기여서 다들 바쁘셨고, Go 코드도 다뤄보고 싶었기 때문에 허락을 받고 개발 서버에서 필요한 API를 추가, 수정하는 경험도 해보았습니다.\n팀장님의 추천\n단기간에 적응하여 업무에 바로 투입이 가능했고 기본적인 프로세스 구성이 가능하며 더 나은 프로세스를 생각하는 팀원으로 기대가 컸으나, 개인적인 사정으로 함께하지 못해 안타까웠습니다.\n교육 # 기간 교육 과정 배운 것 회고 2022 08 42 Seoul - 피신 Shell, C 링크 2021 09 - 11 멋쟁이 사자처럼 - 스타트업 스쿨 Django, Dart 링크 2020 07 - 10 구공팩토리 - 웹 개발 Web, Js 42에서의 경험\n쉘 환경에서 파일 권한 관리, 검색, 스크립트를 이용해 문자열을 가공하는 것 등에 익숙해졌고 C 프로그램을 작성하면서 데이터가 메모리에 어떤 식으로 입출력되는지 이해할 수 있게 되었습니다.\n멋쟁이 사자처럼에서의 경험\n실제 사용되는 서비스를 만들고자 했었기 때문에 어떤 기술 스택을 사용해야할지 능동적으로 찾아보고 공부하는 과정에서 디자인부터 인프라까지 전체 흐름을 이해할 수 있게 되었습니다.\n구공팩토리에서의 경험\n웹 환경이 어떤 구성 요소로 이루어져 있는지, 자바스크립트가 어떻게 동작하는지 대략적으로 이해할 수 있었고 간단한 풀스택 서비스를 구축해보며 관계형 데이터베이스 모델링부터 MVC 디자인 패턴까지 경험할 수 있었습니다.\n프로젝트 # 기간 이름 한 줄 설명 개발 스택 데모 2022 08 러브캡슐 좋아하는 사람을 찾아줍니다. Dart/Flutter + Firebase 동영상 2021 10 제제 화초 키우는 사람을 위한 SNS. Dart/Flutter + Firebase 동영상 2020 08 주차장 시뮬레이터 주차장 출입 기록 프로그램. 바닐라Js + NodeJs + MariaDB 동영상 러브캡슐을 만들 때의 경험\nSMS 인증 코드 자동 인증 로그인을 구현하며 플러터 코드가 안드로이드 네이티브 코드와 어떻게 상호작용 하는지 조금 이해할 수 있었고 앱 푸시 메시지를 구현하며 Firebase의 Cloud Function이 어떤 식으로 작동하는지 이해할 수 있었습니다. 무한 스크롤과 채팅 기능을 구현해봤고, 가입 시 자동으로 닉네임과 캐릭터가 생성되어 DB에 저장되는 재미있는 기능도 개발해보았습니다.\n제제를 만들 때의 경험\n멋쟁이 사자처럼 과정에서 개발했었습니다. 틱톡과 유사한 비디오 SNS 서비스를 만들었습니다. 비디오 저장에 대해 고민하다 Youtube가 대용량의 비디오 데이터들을 어떻게 저장하고 관리하는지 찾아보았고, 확장성을 고려한 DB 및 인프라 관리 방법들에 대해 알게 되었습니다. 하지만 관련 문제는 사용자가 생긴 후에 고민하기로 했고, 플러터 프로젝트의 개발, 배포가 편리한 Firebase(GCP)에서 제공하는 스택으로 빠르게 개발하기로 했습니다. 짧은 개발 기간 내 작동하는 서비스를 만들기 위해 최선을 다했던 경험으로 하려면 할 수 있다는 자신감을 얻을 수 있었습니다.\n주차장 시뮬레이터\n처음 프로그래밍을 배웠던 구공 팩토리에서 학습을 목표로 개발했습니다. UML 다이어그램을 그려가며 관계형 DB를 모델링해봤고 Node Express를 사용해 웹 서버를 구축하고, 자바스크립트로 DOM을 조작하는 연습을 해보았습니다. 서버 코드를 MVC 디자인 패턴을 적용해 개발했는데 모델, 뷰, 컨트롤러 각자의 역할에 대해 고민해볼 수 있었습니다.\n컴퓨터 기술 # 익숙한 도구 # 언어\nJavascript(Web), Dart, Lua, Fennel, Markdown, Org, SQL\n환경\nLinux (Ubuntu, Arch), GCP (Firebase)\n경험해 본 도구 # 언어\nJavascript(Node), Rescript, C, Go, Clojure, Elisp, Python\n환경\nLinux (CentOS), Windows (wsl2), Docker, AWS (EC2)\n언어 # 영어 : 중상 (TOEIC 925 - 2016년)\n관심 # Lisp, Emacs, 오픈 소스, 텍스트 작성 도구. \u0026lt;2022-10-11 Tue\u0026gt; 읽기 쉬운 코드를 작성하는 방법. \u0026lt;2022-10-18 Tue\u0026gt; "}]