[{"id":0,"href":"/ko/posts/221020193116-emacs%EC%97%90%EC%84%9C_gmail_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-ko/","title":"Emacs에서 Gmail 사용하기","section":"기록들","content":" 목표 # Doom emacs에서 Gmail을 수발신 하기 위해 필요한 설정들과 그 과정에서 배운 것들을 기록하기 위함.\n이맥스내에서 필요한 설정 # ~/.doom.d/init.el 파일 # (doom! ;;... :email ;; 이 부분 주석 해제 (mu4e +org +gmail)) mu4e란 # mu for emacs 라는 뜻의 이름인 듯 하다. 위 mu4e 변수 위에 K 키를 누르면 Readme문서를 확인할 수 있다.\nmu는 maildir-utils 의 약자이다. maildir 포맷 디렉터리 내의 이메일 메시지들을 다루는 도구 모음이다. 커맨드라인에서 메시지들을 색인, 검색, 추가, 삭제, 확인할 수 있다. mu4e가 mu에 의존하니 우선 mu를 OS 패키지 매니저에서 설치하거나 리포지터리에서 클론해 직접 빌드해주어야 한다.\nmu 설치 # # Arch yay -S mu # MacOS brew install mu # Debian/Ubuntu apt-get install maildir-utils mu4e mu를 설치하고 나면 man mu 혹은 man mu-easy 로 매뉴얼을 확인할 수 있다.\nisync 설치 # mail 서버의 maildir와 로컬 maildir를 동기화하기 위해서는 isync (mbsync) 혹은 offlineimap을 사용해야 한다.\nyay -S isync 그 후 유저 홈 디렉터리에 설정 파일을 작성해주어야 한다. 아치 위키의 설명대로 설정해주었으나 잘 되지 않아서 검색해보니 /usr/share/doc/isync/examples/mbsyncrc.sample 위치에 공식 설정 레퍼런스 파일이 있었다. 하지만 공식 레퍼런스에 설정되어 있는 RequireSSL 옵션은 deprecated 되었고, SSLType 옵션을 사용하는 것이 맞다고 한다.\n다른 이메일 클라이언트에서 Gmail 확인하기 구글 문서를 확인하고 최종적으로 다음과 같이 설정해주었다.\n~/.mbsyncrc 파일 # # IMAP 접속 계정 정보를 여기에 설정한다. IMAPAccount gmail Host imap.gmail.com User YOUR_ID # 비밀번호는 PassCmd에 설정한 gpg 명령어로 .mailpass.gpg에 저장한 암호를 복호화하여 사용한다. PassCmd \u0026#34;gpg2 -q --for-your-eyes-only --no-tty -d ~/.mailpass.gpg\u0026#34; Port 993 SSLType IMAPS # The following line should work. If you get certificate errors, uncomment the two following lines and read the \u0026#34;Troubleshooting\u0026#34; section. CertificateFile /etc/ssl/certs/ca-certificates.crt #CertificateFile ~/.cert/imap.gmail.com.pem #CertificateFile ~/.cert/Equifax_Secure_CA.pem # 리모트 저장소 계정에 위에서 작성한 계정 이름을 적는다. IMAPStore gmail-remote Account gmail # 동기화할 로컬 저장소 정보를 작성한다. MaildirStore gmail-local SubFolders Verbatim Path ~/mailbox/Gmail/ Inbox ~/mailbox/Gmail/Inbox Channel gmail Far :gmail-remote: Near :gmail-local: # Exclude everything under the internal [Gmail] folder, except the interesting folders Patterns * ![Gmail]* \u0026#34;[Gmail]/Sent Mail\u0026#34; \u0026#34;[Gmail]/Starred\u0026#34; \u0026#34;[Gmail]/All Mail\u0026#34; # Or include everything #Patterns * # Automatically create missing mailboxes, both locally and on the server Create Both # Sync the movement of messages between folders and deletions, add after making sure the sync works Expunge Both # Save the synchronization state files in the relevant directory SyncState * gmail IMAP 사용 설정 # gmail 페이지 우측 상단 톱니바퀴 버튼을 누르면 모든 설정 보기 버튼이 있다.\nFigure 1: gmail IMAP 설정\n앱 비밀번호 설정 # 구글 계정관리 페이지 보안 탭으로 들어가면 앱 비밀번호를 설정할 수 있다. 여기서 말하는 앱이란 앞서 설정한 mbsync를 의미하는 것 같다. mbsync가 구글 서비스에 접속하려할 때 사용하는 비밀번호인 것이다. 따라서 여기서 설정하는 비밀번호를 gpg를 사용해 로컬에 저장해두면 된다.\nFigure 2: google app password 설정\ngpg 사용법 # 더 상세한 설명은 기계인간님 블로그에서 확인할 수 있다.\n# gpg로 키를 생성한다. gpg --generate-key # 구글 계정설정 보안탭에서 설정한 앱 비밀번호를 다음 파일에 작성한다. echo \u0026#34;app-password\u0026#34; \u0026gt;\u0026gt; ~/.mailpass # gpg 해당 비밀번호를 암호화한다. 그러면 ~/.mailpass.gpg 파일이 생긴다. gpg -e ~/.mailpass mu maildir init # 우선 위에서 설정한 로컬 MaildirStore 구조에 맞게 디렉터리를 생성해준다.\nmkdir -p ~/mailbox/Gmail mu init 해준다.\nmu init --maildir=\u0026#34;~/mailbox/Gmail\u0026#34; --my-address=\u0026#34;YOUR-ID@gmail.com\u0026#34; # 문제 없다면 다음과 같은 결과가 나온다. #+begin_example +-------------------+---------------------------------+ | maildir | /home/user/mailbox/Gmail | +-------------------+---------------------------------+ | database-path | /home/user/.cache/mu/xapian | +-------------------+---------------------------------+ | schema-version | 465 | +-------------------+---------------------------------+ | max-message-size | 100000000 | +-------------------+---------------------------------+ | batch-size | 250000 | +-------------------+---------------------------------+ | created | Thu 20 Oct 2022 09:13:33 PM KST | +-------------------+---------------------------------+ | personal-address | YOUR-ID@gmail.com | +-------------------+---------------------------------+ | messages in store | 0 | +-------------------+---------------------------------+ | last-change | never | +-------------------+---------------------------------+ | last-index | never | +-------------------+---------------------------------+ #+end_example 이메일 동기화 # # 위 mbsync 설정 파일에 작성한 Channel 이름으로 명령어를 실행하면 된다. # 본인 계정의 메일박스들이 제대로 출력되는지 -l 옵션으로 확인해본다. mbsync -l gmail # 이상없이 출력된다면 -L 옵션으로 pull 해올 수 있다. mbsync -L gmail 이맥스에서 gmail 사용해보기 # 이제 SPC o m 로 mu4e 를 열고 u 눌러주면 알아서 메일을 가져와준다.\nFigure 3: mu4e test\n"},{"id":1,"href":"/ko/posts/221018205036-%EC%BD%94%EB%93%9C%EB%A5%BC_%EC%9E%98_%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0_%EC%9C%84%ED%95%B4%EC%84%9C%EB%8A%94-ko/","title":"코드를 잘 작성하기 위해서는","section":"기록들","content":" 내 고민에 대한 고마운 분의 조언 # 이전에 작성한 코드가 읽기 힘들어서 고민이다. # 코드(를 포함한 모든 형식의 글)은 후에 읽어야 할 사람을 생각하며 써야 한다. 경력이 쌓일수록 이런 능력이 생겨야 하고, 생길 것이다. \u0026ldquo;프로그래머의 뇌\u0026quot;라는 책을 읽어보길 권하셨다. 코드를 잘 작성하는 능력보다 코드를 잘 읽는 능력이 상대적으로 과소평가 되어있다. 코드를 잘 읽는 연습을 해보자. 앞으로 어떤 기술 스택을 주로 공부해야 할지 잘 모르겠다. # 앞으로 웹베이스(브라우저와 Js런타임)의 에코 시스템이 더욱 커질 것이라고 생각한다. "},{"id":2,"href":"/ko/posts/221018195600-youtube%EB%8A%94_%EB%B9%84%EB%94%94%EC%98%A4%EB%A5%BC_%EC%96%B4%EB%96%BB%EA%B2%8C_%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94%EA%B0%80-ko/","title":"youtube는 비디오를 어떻게 저장하는가","section":"기록들","content":"원문\n요약 # 서버는 마이크로 서비스로 python, c, c++, java, go로 작성되어 있다. DB는 Vitess 로 돌리는 MySql 사용. Memcache 는 Caching에 사용. Zookeeper 는 node co-ordination. node co-ordination이 뭐지?\n데이터 흐름 # Figure 1: 유튜브 아키텍쳐\n자주 요청되는 비디오는 CDN server에 두고 별로 인기 없는 비디오는 DB에서 직접 가져온다.\n시작점 # 유튜브는 2005년 시작했고 2006년 11월 구글에 인수되었다. 구글에 인수되기 전에는 2명의 시스템 관리자, 2명의 소프트웨어 설계자, 2명의 기능 개발자, 2명의 네트워크 엔지니어, 1명의 DBA 로 구성되어 있었다. youtube도 당연하지만 하나의 DB 인스턴스에서 출발했다. 많아지는 요청에 따라 수평적으로 RDB를 확장해야할 필요를 느낌. 주인-노예 복제 전략 # DB를 여러 인스턴스로 복제함 원본 DB에서만 입력(쓰기)을 받는다. ( 원본 DB를 master라고 부름 ) 원본 DB가 복제된 DB로 입력된 데이터를 넣어준다. ( 복제 DB를 replica라고 부름) 출력(읽기)는 복제된 DB와 원본 DB 모두에서 수행된다. 이 구조에는 문제가 있는데 master와 replica가 기록하고 있는 데이터가 다른 시점이 존재하게 된다는 것이다. master에 입력된 데이터가 replica에 업데이트 되기 전에 플레이 가능한 비디오 목록 요청이 들어오면 업데이트 이전의 데이터 목록을 유저에게 전송하게 된다. 하지만 유저는 별로 신경쓰지 않는다. 선택한 비디오가 제대로 틀어지기만 하면 되는것이다. 시간이 지나면 master와 replica 사이의 데이터 차이는 결국 같아진다.\n하지만 이 master-slave replication 전략에도 한계가 있는 것 같다.\n앱이 대박나서 입소문을 타고 사용자들이 급증한다. 너도 나도 자기 동영상을 업로드하기 시작한다. 그러면 하나의 master DB로는 쓰기 작업의 부하를 혼자 감당하지 못하게 될 것이다. 그럼 이제 어떻게 해야할까?\nSharding (조각내기) # 샤딩이란\n다음 전략은 DB를 쪼개는 것이다. # Sharding은 관계형 DB를 확장하는 여러 방법 중 하나이다.\n앞서 설명한 master-slave replication외에 master-master replication, federation \u0026amp; de-normalization 등이 있다 고 하는데 나머지는 머리 아프니 다음에 알아보자. 데이터들을 수평적으로 여러 머신에 쪼개서 보관하고 관리하자. 그렇게 하면 DB가 받는 부하가 나눠진다.\n예를 들면 User 데이터만 다루는 서버와 Payment 데이터만 다루는 서버를 나누어 API를 통해 데이터를 교환하게 만드는 식이다. 하지만 서버를 분산한다는 것은 쉬운 일이 아니다. 원하는 데이터를 추출하기 위해서는 쪼개진 DB 서버끼리 네트워크를 통해 소통해야 함으로 지연되는 시간이 생겨 속도가 저하된다. 또한 복잡해진 구조 때문에 관리도 어려워진다.\n그럼에도 불구하고 서비스가 성장하게 되면 해야하는 일이다. 기하급수적으로 높아지는 QPS(query per second)를 하나의 DB, 하나의 서버가 물리적으로 감당할 수가 없다. DB 쪼개기를 성공적으로 마쳤다면 이제 쓰기 작업을 여러 대의 서버 컴퓨터에서 나눠서 처리할 수 있게 되었다.\n너무 고맙게도 앱 사용자가 더 늘어난다. 너무 많은 양의 데이터가 한 번에 마구 쏟아진다. 근데 나눠놓은 서버 중에 하나가 열이 받았는지 내가 뭘 잘못했는지 자꾸 꺼진다. 나도 열이 받는다. 어떻게 해야할까?\n재난 관리 # 세상에는 예측 못할 일들이 너무 많다. 갑자기 지진이 나서 서버 컴퓨터가 다 고장날 수도 있고 중국 산업 스파이가 컴퓨터를 통째로 들고 튈수도 있다. 하지만 대비할 수 있다.\n전 세계에 여러 대의 데이터 센터를 두면 된다. 그리고 데이터들을 동기화한다. 전 세계에 데이터 센터를 나눠두게 되면 사용자 요청에 좀 더 빠르게 대응할 수 있다는 점이 또 다른 이점이다. 서울에서 요청된 데이터는 서울에 위치한 데이터 센터에서 보내주고 유럽에서 요청된 데이터는 유럽의 데이터 센터에서 보내준다.\n최적화되지 않은 full table scan query들은 종종 모든 데이터베이스를 죽이기도 한다. 나쁜 쿼리들로부터 보호되어야 한다. 모든 서버들은 효율적인 서비스를 보장하기 위해 추적되어야 한다. 이제 인프라가 너무 복잡해졌다. 머리 아프다. 개발자들은 이 모든 복잡성을 추상화한 시스템이 필요하다.\n최소한의 노력으로 관리하고, 확장도 더 쉽게 하고 싶다. 이제 어떻게 할까?\nVitess # Vitess\nSqlDB의 수평적 확장이 가능하게 하는 쿠버네티스 기반 DB 관리 시스템 # 유튜브, 슬랙, 깃헙, 스퀘어 등에서 사용된다. Go로 작성됨.\nVitess는 개발자가 직접 DB 쪼개기 로직(만약 payment DB의 부하가 50% 이상이면 하나의 payment DB 서버를 더 생성해줘)를 직접 앱에 작성하지 않아도 된다. Sharding 기능이 내장되어 있다. Fail-Over(장애 발생시 예비 시스템 가동)와 Backup도 자동으로 수행한다. 또한 해당 자원에 집중적인 쿼리로 재작성해주고 데이터를 캐싱해주는 등의 방식으로 DB 성능도 높여준다.\nRDB의 ACID, 일관성을 가지는 동시에 noSQL처럼 쉽게 수평 확장을 이루고 싶다면 Vitess가 필요하다.\n클라우드에 배포하기 # vitess는 클라우드 환경이 기본이다. 클라우드 네이티브 분산 데이터베이스. 요즘 컴퓨팅 시대에는 모든 규모 있는 서비스들은 많은 언어로 개발되고 있다. 서비스의 많은 유즈 케이스를 잘 다루기 위해서는 관계형과 NoSQL 모두 필요하기 때문이다.\nCDN # 유튜브는 구글의 글로벌 네트워크를 이용해서 콘텐츠 전송에 낮은 지연시간, 낮은 비용을 이룬다. 멀리 돌아왔다. 이제 어떻게 유튜브가 비디오를 저장하는지! Storage 얘기를 한다.\nData Storage - 유튜브는 미친 데이터 용량을 어떻게 저장하는가! # 구글 파일 시스템(GFS, Google File System)\n비디오들은 웨어하우스만한 크기의 구글 데이터센터 하드드라이브들에 저장된다. 데이터는 google file system과 BigTable로 관리된다.\nGFS(google file system) # 많은 양의 데이터를 분산 환경에서 관리하기 위해 구글이 개발한 분산 파일 시스템\nBigTable # 수천 대의 기계에 분산된 patabyte급의 데이터를 처리하기 위해 구글 파일 시스템 위에 구축된 저지연 분산 데이터 저장 시스템.\n비디오는 HDD에 저장된다. 관계, 메타 데이터, 사용자 선호 정보, 프로필 정보, 계정 설정, 비디오를 가져오기 위해 필요한 관계 정보 등은 MySQL에 저장된다.\n"},{"id":3,"href":"/ko/posts/221018174449-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85_%EC%8A%A4%EC%BF%A8_%ED%9A%8C%EA%B3%A0-ko/","title":"스타트업 스쿨 회고","section":"기록들","content":" 멋있는 사람들이 다 모인 곳. # 1년이나 지났지만 그 장소, 그 사람들의 진지하고 열정적인 바이브가 그립다. 다들 스타트업을 하려고 모인 사람들이다 보니 모두 행동력이 좋았다. 나는 굉장히 사교적이지 못한 성격인데 운이 좋게도 좋은 사람들이 다가와줘서 많이 배울 수 있었다. 뭔가 나 자신이 상대적으로 너무 부족한 느낌이 들어 나를 더 크게 포장하곤 했었는데 지금 돌이켜보니 너무 부끄럽다. 겸손하고도 당당할 수 있어야 한다.\n배운 점. # 멘탈과 관련해서 # 내가 느낀 것은 아이디어 자체는 정작 크게 중요하지 않다는 것이었다. 그 사람, 구성원이 얼마나 진지한지, 구현의 의지가 강한지가 중요하다는 것이다. 하나 더 달자면, 아니라고 판단되면 그 좋은 생각을 죽일 수 있는가. 투자자의 입장에서만이 아니라, 나 자신이 나를 봤을 때. 나는 냉정하지도 못했고, 순진했고, 진지하지도 못했다.\n투자와 관련해서 # 이 과정 전에 나는 다음과 같이 생각했다.\n좋은 아이디어가 있다면 -\u0026gt; 사업계획서를 작성하여 -\u0026gt; 투자를 받으러 다닌다 -\u0026gt; 투자금으로 구현한다. -\u0026gt; 사업화한다. 이후에는 조금 달라진 것이\n좋은 아이디어가 있다면 -\u0026gt; 구현한다 -\u0026gt; 사람들이 사용한다면 -\u0026gt; 사업계획서를 작성하고 -\u0026gt; \u0026hellip; -\u0026gt; 사업화한다.~ 사람마다 다른 방식으로 접근하겠지만 나에게는 시간이 걸려도 이게 맞는 순서인 것 같다.\n개발과 관련해서 # 작은 앱의 개발 과정을 처음부터 끝까지 계획하고 기술 요구사항에 맞는 대안들을 조사해 보면서 많은 것을 배웠다.\nAWS가 아닌 Firebase를 배포 환경, 백엔드로 정한 이유는 구글의 프리티어 정책이 더 실패 시에 안전해보였고, 앞으로 사업화가 되더라도 앱 서비스 스타트업에 대한 지원 사업이 활발해보였다. AWS도 동일한 지원 정책이 있었던 것으로 기억하지만 동일하다면 플레이스토어를 운영하는 구글을 선택하지 않을 이유가 없어보였다. + 기술 문서, 콘솔 인터페이스가 더 배우기 쉬웠다.\n사용자가 많아지는 경우 AWS가 더 비용적으로 효율적이라고 하지만 그건 그 때가서 마이그레이션하면 될 것으로 판단했다. 사용자가 많은 경우 투자 유치도 쉬워질 것이고, 돈이 있다면 사람을 구할 수 있다. 비용 효율성은 그때 가서 따져야 한다고 생각했다. 당장은 빠른 구현이 최우선이었다.\n그리고 가장 큰 이유, 구현하려한 비디오 SNS 서비스는 사용자 컨텐츠 검열이 큰 숙제였는데 구글에서 제공되는 머신러닝 API를 사용하면 좋겠다고 생각했다. AWS도 동일한 서비스를 제공하지만 당시 인공지능은 구글이 더 낫다는 글들을 많이 보아서 결국 구글로 결정하게 되었다.\n아쉬운 점 # 나 자신에게 정말 많은 기대와 실망을 했던 기간이었다. 나의 능력을 제대로 파악하지 못한 탓에 무리한 계획을 세웠고, 다트와 플러터를 써보고 싶은 욕심과, 서비스를 출시한다면 앱을 만드는 것이 더 낫다는 일차원적인 판단으로 커리큘럼에서 가르쳐주는 기술 스택을 사용하지 않았다.\n그 때문에 개발에 상대적으로 경험이 적었던 팀원들의 학습 의욕을 저하시켰고, 결과적으로 좋은 사람들에게 피해를 주었다. 충분히 소통을 했다고 생각했지만 소통이 아니었다. 결국 개발에 관한 부분은 아주 조금이나마 더 알고 있는 내 판단을 존중해주었었고, 나는 그 때 내가 아니라 팀원들의 입장에서 생각했어야 했다. 내가 그 사람들의 학습 기회를 박탈한 것이나 다름 없었다.\n다시 이런 기회가 온다면 나의 욕심은 반드시 없앨 것이다. 정말 후회된다.\n"},{"id":4,"href":"/ko/posts/221018165518-42%EC%84%9C%EC%9A%B8_%ED%94%BC%EC%8B%A0_%ED%9A%8C%EA%B3%A0-ko/","title":"42서울 피신 회고","section":"기록들","content":" C가 왜 중요한지 느낄 수 있었다. # 자바스크립트로 처음 코드를 배웠기 때문에 동적이고, 유연한 프로토타입 기반의 언어를 기준으로 프로그램을 생각하고 있었다. 그냥 코드를 작성하면 언어가, 컴파일러가 알아서 다 해주니까, 따로 신경써본 적이 없었고, 그러다보니 그 블랙박스 내의 동작은 내가 상상해볼 수 없는 영역이었다.\n\u0026ldquo;잘 작성되었고, 빠르고 인기가 많은\u0026rdquo; 라이브러리들을 찾아 거기서 제공해주는 API를 매뉴얼대로 작성하는 것이 전부였다. 뭔가 부족하다고 생각이 들었고 이대로 괜찮을지에 대한 불안감은 늘 있었지만 정작 나 스스로 블랙박스를 열어볼 용기와 인내는 없었던 것 같다.\n운이 좋게도 피신 과정을 진행하며 C의 Array를 다뤄보았는데, 그 과정에서 언어가 컴퓨터에 어떤 방식으로 자료를 입출력하는지 들여다볼 수 있었다. 피신 전에는 부끄럽게도 Array가 List와 같은 것을 말하는 다른 단어인 줄 알고 있었다.\n내가 작성한 코드를 남에게 잘 설명할 수 있다는 것. # 42 과정은 컴퓨터 과학 로드맵을 과제로서 제시해주고 동료 평가라는 방식으로 과제를 해결해나간다. 과제를 해결하면, 동료가 옆 자리에 와서 코드 리뷰를 해주고, 점수를 부여해준다. 작성한 코드를 잘 설명하지 못하면, 평가자는 본인이 쓴 코드가 아니라고 판단하고 실패를 줄 수도 있다.\n나는 그 동안 거의 혼자서 코드를 작성했었고 다른 사람에게 내 코드를 설명하고, 평가받을 일이 잘 없었다. 그러다 보니 처음에는 조금 어색하고 힘들었지만 진행되며 이런 방식이 내 학습에 얼마나 큰 도움이 되는지 몸소 실감할 수 있었다.\n내가 풀고있는 문제를 본인의 문제처럼 고민해주고 해결책을 제시해주시는 고마운 분도 있었고, 내가 모르고 있던 지식을 설명해주어 부족한 부분을 채워주시는 분도 있었다. 그런 식으로 동료가 전달해주는 지식도 좋았지만, 정말 좋았던 것은 머릿 속으로만 굴리던 코드 흐름을 입 밖으로 내면서 코드와 내 복잡한 머릿 속이 정돈되는 느낌을 받았다.\n설명할 수 없으면 알고 있다고 할 수 없다.\n그래서 앞으로 코드를 작성하고 다른 사람에게 말로서 설명할 기회가 잘 없다고 하더라도, 배운 것을 글로써 출력하는 습관을 들여야겠다고 느꼈다.\n세상에 잘하는 사람들이 이렇게 많다. # 전공자는 잘하고, 비전공자는 못한다고 생각하진 않는다. 내가 비전공자이기 때문에 못한다는 변명을 나도 모르게 하게 될 수 있기 때문이다.\n동료 평가를 다니며 느낀 것은 잘하는 사람들이 정말 많다는 것이었다. 설명을 들으며 이 사람은 머리가 정말 좋구나, 이 사람은 엄청 성실하구나, 진지하게 공부하고 있구나. 그런 생각을 하며 나 자신이 많이 초라하게 느껴질 때도 있었다.\n지금 잘하진 않더라도 앞으로가 기대되는 분들도 많았다. 점수로 본 과정의 당락이 결정되는데도 진도를 그다지 신경쓰지 않고 잘 모르는 것은 깊이 있게 알고 넘어가려는 자세를 가진 분을 보면 앞으로 엄청 잘하게 되실 것 같다는 생각이 들었다.\n아쉬웠던 점 # 과정에 대해 아쉬운 점은 없지만, 코로나에 걸려서 너무 아쉬웠다. 더 많이 배우고, 더 많은 사람들과 얘기를 나눠보고, 더 재밌을 수 있었을텐데.\n"},{"id":5,"href":"/ko/posts/221018160725-pandoc%EC%9C%BC%EB%A1%9C_md%ED%8C%8C%EC%9D%BC_pdf%EB%A1%9C_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-ko/","title":"pandoc으로 md파일 pdf로 변환하기","section":"기록들","content":" 패키지 매니저로 pandoc, wkhtmltopdf 를 설치한다.\nyay pandoc yay wkhtmltopdf css 파일을 같은 디렉터리에 위치시킨다.\nwget https://gist.githubusercontent.com/dashed/6714393/raw/ae966d9d0806eb1e24462d88082a0264438adc50/github-pandoc.css css를 적용한 html문서를 만들고, pdf로 출력한다.\npandoc -t html5 --metadata pagetitle=\u0026#34;resume.md\u0026#34; --css=github-pandoc.css resume.md -o res.pdf 상세한 설명은 스택 오버플로우에\u0026hellip;\n"},{"id":6,"href":"/ko/posts/221018112544-%EC%8A%A4%ED%83%9D_stack-ko/","title":"스택 (Stack)","section":"기록들","content":"스택은 자료를 쌓아올리는 방식으로 저장한다. 책을 쌓아둔 것과 같다. 5권의 책을 쌓아뒀을 때, 첫 번째 책을 꺼내보려면 그 책 위의 네 권을 먼저 들어올려야 한다. 이러한 특징을 FILO(First In Last Out), LIFO(Last In First Out). 처음 들어온 게 마지막에 나간다고 줄여 말한다.\n스택은 추상적 자료 구조이고, 이를 구체적으로 어떻게 구현할지는 구현자 마음대로이다.\n"},{"id":7,"href":"/ko/posts/221017200019-%EC%B6%94%EC%83%81%EC%A0%81_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0-ko/","title":"추상적 자료 구조","section":"기록들","content":"추상 자료형이 말 그대로 자료의 형식만을 정의하는 가장 높은 단계의 추상화라면,\n추상적 자료구조는 해당 자료형을 구체적으로 구현하기 위한 조건들도 함께 정의한다.\n\u0026ldquo;스택(stack)이라는 자료형(data type)의 입출력을 위한 방법에는 push와 pop이 있고, 이 연산들은 O(1)만에 이뤄져야 한다.\u0026quot;\n고 정의된 것이 있다면 이것을 추상적 자료구조라고 말하며, 이를 구현한 것을 구체적 자료구조라고 말한다.\n이렇게 위키피디아 한글 문서에서는 설명하고 있으나 영문판에서는 \u0026lsquo;추상 자료구조\u0026rsquo;와 \u0026lsquo;추상 자료형\u0026rsquo;의 정의 간에 특별한 구분을 두고 있지는 않는 것 같다. 추상 자료형과 자료구조의 차이 정도만 인식하고 있으면 될 것 같다.\n자료구조를 어떻게 정의하여 내부적으로 어떻게 구현했는가는 작성자에게 달려있기에 프로그래밍 언어에 따라 다르다. 예를 들어 스택 (Stack)은 리스트로도 구현할 수 있고 배열 (Array)로도 구현할 수 있다.\n"},{"id":8,"href":"/ko/posts/221017194720-%EC%B6%94%EC%83%81_%EC%9E%90%EB%A3%8C%ED%98%95-ko/","title":"추상 자료형","section":"기록들","content":" 추상 자료형이란 # 추상 자료형은(Abstract Data Type, ADT)는 자료의 형태와 그와 관계된 연산을 수학적으로만 정의한 것이다. 해당 자료형이 내부적으로 어떤 방식으로 구현되는지는 관심이 없다. \u0026lsquo;형\u0026rsquo;과 \u0026lsquo;Type\u0026rsquo;, \u0026lsquo;자료\u0026rsquo;와 \u0026lsquo;Data\u0026rsquo;가 동일한 뜻인 것을 가끔 인지하지 못할 때가 있다.\n정수는 추상 자료형(ADT)이다. \u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip;의 값으로 정의되며, 연산은 더하기, 빼기, 곱하기, 나누기가 가능하고, 대소 비교 등도 가능하다.\n추상적 자료형은 구현 방법을 명시하고 있지 않다는 점에서 자료 구조와 다르다. 비슷한 개념의 추상적 자료 구조는 각 연산의 시간 복잡도를 명기하고 있지만 추상적 자료형에서는 이것조차 명기하지 않는다.\n추상 자료형의 정의 # 어떻게 정의되어야 하는지에 대한 표준화된 약속은 없다. 넓게 나눠보면 \u0026ldquo;명령적\u0026rdquo;(혹은 \u0026ldquo;절차적\u0026rdquo;), \u0026ldquo;기능적\u0026rdquo;(혹은 \u0026ldquo;공리적\u0026rdquo;)인 정의 방식이 있다.\n"},{"id":9,"href":"/ko/posts/221017180001-array-ko/","title":"배열 (Array)","section":"기록들","content":"배열은 연속적인 자료의 나열이다. 배열 내에는 동일한 형(type)의 자료가 나열되어야 한다. 보통의 프로그래밍 언어에서 인덱스는 0부터 시작한다. 루아는 특이하게 1부터 시작한다.\nC에서는 선언 시에 배열로 사용될 메모리 주소의 범위를 정적으로 할당한다. 반면 Javascript에서의 배열은 동적으로 할당되며, 메모리 주소의 연속일 뿐인 C와 다르게 다양한 메서드를 포함하고 있는 객체로 구현되어 있다. 내부 작동은 브라우저의 엔진마다 다를 수 있다고 한다.\nconst arr = [1, 2, 3]; arr[1]; \u0026gt; 2 arr[\u0026#34;1\u0026#34;]; \u0026gt; 2 인덱스는 특이하게 \u0026ldquo;1\u0026quot;로도 1로도 접근 가능한데 내부적으로 toString() 메소드를 호출하기 때문이라고 한다.\n"},{"id":10,"href":"/ko/posts/221017175656-data_structure-ko/","title":"자료구조","section":"기록들","content":"자료구조란 추상 자료형을 구현한 것. 자료(데이터)의 모임, 자료간의 관계, 자료의 입출력 방식.\n왜 자료구조를 알아야 할까 # 주어진 문제를 해결할 때 자료구조를 선택하고 나면 어떤 알고리즘을 사용할지 명확해진다. 구현의 난이도, 결과물의 성능이 자료구조에 크게 의존한다.\n자료구조의 5가지 필수 구성 요소 # 참조 링크\n어떻게 접근 할 것인가. 어떻게 입력 할 것인가. 어떻게 삭제 할 것인가. 어떻게 탐색 할 것인가. 어떻게 정렬 할 것인가. 자료구조 선택 방법 # 자료구조의 분류 # 자료구조는 추상적인 구조인지, 자료간의 관계가 선형(1:1)적인지 비선형적인지 등으로 분류 되어진다.\n추상적 자료 구조 # 스택 (Stack) # 큐 # 트리 # 그래프 # 선형 자료 구조 # 배열(Array) # 리스트(List / Sequence) # "},{"id":11,"href":"/ko/resume/","title":"이력서","section":"소개","content":" 이력서 # pdf 버전\n박기둥 # 그림 그리길 좋아하다 무언가 작동하는 것을 만드는 것을 좋아하게 되었습니다.\n재밌고 새로운 것을 만들어 보고 싶다는 생각으로 프로그래밍을 시작했습니다.\n목적을 이루기 위함보다 그 과정이 즐거워서 작업을 하는 사람이 되고자 합니다.\n개인정보 # 연락처 : 이메일 공부 기록 : 블로그 코드 저장소 : 깃허브 경험 # 직무 # 기간 회사 담당 개발 스택 2021 01 - 08 나무소프트 프론트엔드 개발 Js/React, Go + Docker + AWS 나무소프트에서의 경험\n기업을 대상으로한 보안 스토리지 서비스를 운영하는 회사에서 웹 프론트엔드 개발을 담당했습니다.\n기존의 코드베이스에서는 전역 상태관리로 Redux를 사용했는데 상품 소개와 가입, 인증만을 담당하던 규모가 작은 클라이언트였고, 기능 추가의 여지도 없었기 때문에 Context API를 사용하여 불필요한 코드 복잡도를 낮추었습니다.\n기여한 다른 코드베이스로는 가입한 사용자의 스토리지 콘솔 클라이언트가 있습니다. 여기서는 서버와 클라이언트 데이터의 동기화가 제때 이뤄지지 않는 문제가 있었는데 React query 라이브러리를 도입하여 사용자가 최신의 데이터를 볼 수 있도록 하였습니다.\n중간에 가입 과정의 유저 플로우가 변경되어 서버 API를 수정해야 할 일이 있었는데 사내에서 다른 프로젝트도 병행하던 시기여서 다들 바쁘셨고, Go 코드도 다뤄보고 싶었기 때문에 허락을 받고 개발 서버에서 필요한 API를 추가, 수정하는 경험도 해보았습니다.\n팀장님의 추천\n단기간에 적응하여 업무에 바로 투입이 가능했고 기본적인 프로세스 구성이 가능하며 더 나은 프로세스를 생각하는 팀원으로 기대가 컸으나, 개인적인 사정으로 함께하지 못해 안타까웠습니다.\n교육 # 기간 교육 과정 배운 것 회고 2022 08 42 Seoul - 피신 Shell, C 링크 2021 09 - 11 멋쟁이 사자처럼 - 스타트업 스쿨 Django, Dart 링크 2020 07 - 10 구공팩토리 - 웹 개발 Web, Js 42에서의 경험\n쉘 환경에서 파일 권한 관리, 검색, 스크립트를 이용해 문자열을 가공하는 것 등에 익숙해졌고 C 프로그램을 작성하면서 데이터가 메모리에 어떤 식으로 입출력되는지 이해할 수 있게 되었습니다.\n멋쟁이 사자처럼에서의 경험\n실제 사용되는 서비스를 만들고자 했었기 때문에 어떤 기술 스택을 사용해야할지 능동적으로 찾아보고 공부하는 과정에서 디자인부터 인프라까지 전체 흐름을 이해할 수 있게 되었습니다.\n구공팩토리에서의 경험\n웹 환경이 어떤 구성 요소로 이루어져 있는지, 자바스크립트가 어떻게 동작하는지 대략적으로 이해할 수 있었고 간단한 풀스택 서비스를 구축해보며 관계형 데이터베이스 모델링부터 MVC 디자인 패턴까지 경험할 수 있었습니다.\n프로젝트 # 기간 이름 한 줄 설명 개발 스택 데모 2022 08 러브캡슐 좋아하는 사람을 찾아줍니다. Dart/Flutter + Firebase 동영상 2021 10 제제 화초 키우는 사람을 위한 SNS. Dart/Flutter + Firebase 동영상 2020 08 주차장 시뮬레이터 주차장 출입 기록 프로그램. 바닐라Js + NodeJs + MariaDB 동영상 러브캡슐을 만들 때의 경험\nSMS 인증 코드 자동 인증 로그인을 구현하며 플러터 코드가 안드로이드 네이티브 코드와 어떻게 상호작용 하는지 조금 이해할 수 있었고 앱 푸시 메시지를 구현하며 Firebase의 Cloud Function이 어떤 식으로 작동하는지 이해할 수 있었습니다. 무한 스크롤과 채팅 기능을 구현해봤고, 가입 시 자동으로 닉네임과 캐릭터가 생성되어 DB에 저장되는 재미있는 기능도 개발해보았습니다.\n제제를 만들 때의 경험\n멋쟁이 사자처럼 과정에서 개발했었습니다. 틱톡과 유사한 비디오 SNS 서비스를 만들었습니다. 비디오 저장에 대해 고민하다 Youtube가 대용량의 비디오 데이터들을 어떻게 저장하고 관리하는지 찾아보았고, 확장성을 고려한 DB 및 인프라 관리 방법들에 대해 알게 되었습니다. 하지만 관련 문제는 사용자가 생긴 후에 고민하기로 했고, 플러터 프로젝트의 개발, 배포가 편리한 Firebase(GCP)에서 제공하는 스택으로 빠르게 개발하기로 했습니다. 짧은 개발 기간 내 작동하는 서비스를 만들기 위해 최선을 다했던 경험으로 하려면 할 수 있다는 자신감을 얻을 수 있었습니다.\n주차장 시뮬레이터\n처음 프로그래밍을 배웠던 구공 팩토리에서 학습을 목표로 개발했습니다. UML 다이어그램을 그려가며 관계형 DB를 모델링해봤고 Node Express를 사용해 웹 서버를 구축하고, 자바스크립트로 DOM을 조작하는 연습을 해보았습니다. 서버 코드를 MVC 디자인 패턴을 적용해 개발했는데 모델, 뷰, 컨트롤러 각자의 역할에 대해 고민해볼 수 있었습니다.\n컴퓨터 기술 # 익숙한 도구 # 언어\nJavascript(Web), Dart, Lua, Fennel, Markdown, Org, SQL\n환경\nLinux (Ubuntu, Arch), GCP (Firebase)\n경험해 본 도구 # 언어\nJavascript(Node), Rescript, C, Go, Clojure, Elisp, Python\n환경\nLinux (CentOS), Windows (wsl2), Docker, AWS (EC2)\n언어 # 영어 : 중상 (TOEIC 925 - 2016년)\n관심 # Lisp, Emacs, 오픈 소스, 텍스트 작성 도구. \u0026lt;2022-10-11 Tue\u0026gt; 읽기 쉬운 코드를 작성하는 방법. \u0026lt;2022-10-18 Tue\u0026gt; "}]