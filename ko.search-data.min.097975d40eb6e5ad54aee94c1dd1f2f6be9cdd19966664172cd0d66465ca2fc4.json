[{"id":0,"href":"/ko/posts/221018195600-youtube%EB%8A%94_%EB%B9%84%EB%94%94%EC%98%A4%EB%A5%BC_%EC%96%B4%EB%96%BB%EA%B2%8C_%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94%EA%B0%80-ko/","title":"youtube는 비디오를 어떻게 저장하는가","section":"기록들","content":"원문\n요약 # 서버는 마이크로 서비스로 python, c, c++, java, go로 작성되어 있다. DB는 Vitess 로 돌리는 MySql 사용. Memcache 는 Caching에 사용. Zookeeper 는 node co-ordination. node co-ordination이 뭐지?\n데이터 흐름 # Figure 1: 유튜브 아키텍쳐\n자주 요청되는 비디오는 CDN server에 두고 별로 인기 없는 비디오는 DB에서 직접 가져온다.\n시작점 # 유튜브는 2005년 시작했고 2006년 11월 구글에 인수되었다. 구글에 인수되기 전에는 2명의 시스템 관리자, 2명의 소프트웨어 설계자, 2명의 기능 개발자, 2명의 네트워크 엔지니어, 1명의 DBA 로 구성되어 있었다. youtube도 당연하지만 하나의 DB 인스턴스에서 출발했다. 많아지는 요청에 따라 수평적으로 RDB를 확장해야할 필요를 느낌. 주인-노예 복제 전략 # DB를 여러 인스턴스로 복제함 원본 DB에서만 입력(쓰기)을 받는다. ( 원본 DB를 master라고 부름 ) 원본 DB가 복제된 DB로 입력된 데이터를 넣어준다. ( 복제 DB를 replica라고 부름) 출력(읽기)는 복제된 DB와 원본 DB 모두에서 수행된다. 이 구조에는 문제가 있는데 master와 replica가 기록하고 있는 데이터가 다른 시점이 존재하게 된다는 것이다. master에 입력된 데이터가 replica에 업데이트 되기 전에 플레이 가능한 비디오 목록 요청이 들어오면 업데이트 이전의 데이터 목록을 유저에게 전송하게 된다. 하지만 유저는 별로 신경쓰지 않는다. 선택한 비디오가 제대로 틀어지기만 하면 되는것이다. 시간이 지나면 master와 replica 사이의 데이터 차이는 결국 같아진다.\n하지만 이 master-slave replication 전략에도 한계가 있는 것 같다.\n앱이 대박나서 입소문을 타고 사용자들이 급증한다. 너도 나도 자기 동영상을 업로드하기 시작한다. 그러면 하나의 master DB로는 쓰기 작업의 부하를 혼자 감당하지 못하게 될 것이다. 그럼 이제 어떻게 해야할까?\nSharding (조각내기) # 샤딩이란\n다음 전략은 DB를 쪼개는 것이다. # Sharding은 관계형 DB를 확장하는 여러 방법 중 하나이다.\n앞서 설명한 master-slave replication외에 master-master replication, federation \u0026amp; de-normalization 등이 있다 고 하는데 나머지는 머리 아프니 다음에 알아보자. 데이터들을 수평적으로 여러 머신에 쪼개서 보관하고 관리하자. 그렇게 하면 DB가 받는 부하가 나눠진다.\n예를 들면 User 데이터만 다루는 서버와 Payment 데이터만 다루는 서버를 나누어 API를 통해 데이터를 교환하게 만드는 식이다. 하지만 서버를 분산한다는 것은 쉬운 일이 아니다. 원하는 데이터를 추출하기 위해서는 쪼개진 DB 서버끼리 네트워크를 통해 소통해야 함으로 지연되는 시간이 생겨 속도가 저하된다. 또한 복잡해진 구조 때문에 관리도 어려워진다.\n그럼에도 불구하고 서비스가 성장하게 되면 해야하는 일이다. 기하급수적으로 높아지는 QPS(query per second)를 하나의 DB, 하나의 서버가 물리적으로 감당할 수가 없다. DB 쪼개기를 성공적으로 마쳤다면 이제 쓰기 작업을 여러 대의 서버 컴퓨터에서 나눠서 처리할 수 있게 되었다.\n너무 고맙게도 앱 사용자가 더 늘어난다. 너무 많은 양의 데이터가 한 번에 마구 쏟아진다. 근데 나눠놓은 서버 중에 하나가 열이 받았는지 내가 뭘 잘못했는지 자꾸 꺼진다. 나도 열이 받는다. 어떻게 해야할까?\n재난 관리 # 세상에는 예측 못할 일들이 너무 많다. 갑자기 지진이 나서 서버 컴퓨터가 다 고장날 수도 있고 중국 산업 스파이가 컴퓨터를 통째로 들고 튈수도 있다. 하지만 대비할 수 있다.\n전 세계에 여러 대의 데이터 센터를 두면 된다. 그리고 데이터들을 동기화한다. 전 세계에 데이터 센터를 나눠두게 되면 사용자 요청에 좀 더 빠르게 대응할 수 있다는 점이 또 다른 이점이다. 서울에서 요청된 데이터는 서울에 위치한 데이터 센터에서 보내주고 유럽에서 요청된 데이터는 유럽의 데이터 센터에서 보내준다.\n최적화되지 않은 full table scan query들은 종종 모든 데이터베이스를 죽이기도 한다. 나쁜 쿼리들로부터 보호되어야 한다. 모든 서버들은 효율적인 서비스를 보장하기 위해 추적되어야 한다. 이제 인프라가 너무 복잡해졌다. 머리 아프다. 개발자들은 이 모든 복잡성을 추상화한 시스템이 필요하다.\n최소한의 노력으로 관리하고, 확장도 더 쉽게 하고 싶다. 이제 어떻게 할까?\nVitess # Vitess\nSqlDB의 수평적 확장이 가능하게 하는 쿠버네티스 기반 DB 관리 시스템 # 유튜브, 슬랙, 깃헙, 스퀘어 등에서 사용된다. Go로 작성됨.\nVitess는 개발자가 직접 DB 쪼개기 로직(만약 payment DB의 부하가 50% 이상이면 하나의 payment DB 서버를 더 생성해줘)를 직접 앱에 작성하지 않아도 된다. Sharding 기능이 내장되어 있다. Fail-Over(장애 발생시 예비 시스템 가동)와 Backup도 자동으로 수행한다. 또한 해당 자원에 집중적인 쿼리로 재작성해주고 데이터를 캐싱해주는 등의 방식으로 DB 성능도 높여준다.\nRDB의 ACID, 일관성을 가지는 동시에 noSQL처럼 쉽게 수평 확장을 이루고 싶다면 Vitess가 필요하다.\n클라우드에 배포하기 # vitess는 클라우드 환경이 기본이다. 클라우드 네이티브 분산 데이터베이스. 요즘 컴퓨팅 시대에는 모든 규모 있는 서비스들은 많은 언어로 개발되고 있다. 서비스의 많은 유즈 케이스를 잘 다루기 위해서는 관계형과 NoSQL 모두 필요하기 때문이다.\nCDN # 유튜브는 구글의 글로벌 네트워크를 이용해서 콘텐츠 전송에 낮은 지연시간, 낮은 비용을 이룬다. 멀리 돌아왔다. 이제 어떻게 유튜브가 비디오를 저장하는지! Storage 얘기를 한다.\nData Storage - 유튜브는 미친 데이터 용량을 어떻게 저장하는가! # 구글 파일 시스템(GFS, Google File System)\n비디오들은 웨어하우스만한 크기의 구글 데이터센터 하드드라이브들에 저장된다. 데이터는 google file system과 BigTable로 관리된다.\nGFS(google file system) # 많은 양의 데이터를 분산 환경에서 관리하기 위해 구글이 개발한 분산 파일 시스템\nBigTable # 수천 대의 기계에 분산된 patabyte급의 데이터를 처리하기 위해 구글 파일 시스템 위에 구축된 저지연 분산 데이터 저장 시스템.\n비디오는 HDD에 저장된다. 관계, 메타 데이터, 사용자 선호 정보, 프로필 정보, 계정 설정, 비디오를 가져오기 위해 필요한 관계 정보 등은 MySQL에 저장된다.\n"},{"id":1,"href":"/ko/posts/221018174449-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85_%EC%8A%A4%EC%BF%A8_%ED%9A%8C%EA%B3%A0-ko/","title":"스타트업 스쿨 회고","section":"기록들","content":" 멋있는 사람들이 다 모인 곳. # 1년이나 지났지만 그 장소, 그 사람들의 진지하고 열정적인 바이브가 그립다. 다들 스타트업을 하려고 모인 사람들이다 보니 모두 행동력이 좋았다. 나는 굉장히 사교적이지 못한 성격인데 운이 좋게도 좋은 사람들이 다가와줘서 많이 배울 수 있었다. 뭔가 나 자신이 상대적으로 너무 부족한 느낌이 들어 나를 더 크게 포장하곤 했었는데 지금 돌이켜보니 너무 부끄럽다. 겸손하고도 당당할 수 있어야 한다.\n배운 점. # 멘탈과 관련해서 # 내가 느낀 것은 아이디어 자체는 정작 크게 중요하지 않다는 것이었다. 그 사람, 구성원이 얼마나 진지한지, 구현의 의지가 강한지가 중요하다는 것이다. 하나 더 달자면, 아니라고 판단되면 그 좋은 생각을 죽일 수 있는가. 투자자의 입장에서만이 아니라, 나 자신이 나를 봤을 때. 나는 냉정하지도 못했고, 순진했고, 진지하지도 못했다.\n투자와 관련해서 # 이 과정 전에 나는 다음과 같이 생각했다.\n좋은 아이디어가 있다면 -\u0026gt; 사업계획서를 작성하여 -\u0026gt; 투자를 받으러 다닌다 -\u0026gt; 투자금으로 구현한다. -\u0026gt; 사업화한다. 이후에는 조금 달라진 것이\n좋은 아이디어가 있다면 -\u0026gt; 구현한다 -\u0026gt; 사람들이 사용한다면 -\u0026gt; 사업계획서를 작성하고 -\u0026gt; \u0026hellip; -\u0026gt; 사업화한다.~ 사람마다 다른 방식으로 접근하겠지만 나에게는 시간이 걸려도 이게 맞는 순서인 것 같다.\n개발과 관련해서 # 작은 앱의 개발 과정을 처음부터 끝까지 계획하고 기술 요구사항에 맞는 대안들을 조사해 보면서 많은 것을 배웠다.\nAWS가 아닌 Firebase를 배포 환경, 백엔드로 정한 이유는 구글의 프리티어 정책이 더 실패 시에 안전해보였고, 앞으로 사업화가 되더라도 앱 서비스 스타트업에 대한 지원 사업이 활발해보였다. AWS도 동일한 지원 정책이 있었던 것으로 기억하지만 동일하다면 플레이스토어를 운영하는 구글을 선택하지 않을 이유가 없어보였다. + 기술 문서, 콘솔 인터페이스가 더 배우기 쉬웠다.\n사용자가 많아지는 경우 AWS가 더 비용적으로 효율적이라고 하지만 그건 그 때가서 마이그레이션하면 될 것으로 판단했다. 사용자가 많은 경우 투자 유치도 쉬워질 것이고, 돈이 있다면 사람을 구할 수 있다. 비용 효율성은 그때 가서 따져야 한다고 생각했다. 당장은 빠른 구현이 최우선이었다.\n그리고 가장 큰 이유, 구현하려한 비디오 SNS 서비스는 사용자 컨텐츠 검열이 큰 숙제였는데 구글에서 제공되는 머신러닝 API를 사용하면 좋겠다고 생각했다. AWS도 동일한 서비스를 제공하지만 당시 인공지능은 구글이 더 낫다는 글들을 많이 보아서 결국 구글로 결정하게 되었다.\n아쉬운 점 # 나 자신에게 정말 많은 기대와 실망을 했던 기간이었다. 나의 능력을 제대로 파악하지 못한 탓에 무리한 계획을 세웠고, 다트와 플러터를 써보고 싶은 욕심과, 서비스를 출시한다면 앱을 만드는 것이 더 낫다는 일차원적인 판단으로 커리큘럼에서 가르쳐주는 기술 스택을 사용하지 않았다.\n그 때문에 개발에 상대적으로 경험이 적었던 팀원들의 학습 의욕을 저하시켰고, 결과적으로 좋은 사람들에게 피해를 주었다. 충분히 소통을 했다고 생각했지만 소통이 아니었다. 결국 개발에 관한 부분은 아주 조금이나마 더 알고 있는 내 판단을 존중해주었었고, 나는 그 때 내가 아니라 팀원들의 입장에서 생각했어야 했다. 내가 그 사람들의 학습 기회를 박탈한 것이나 다름 없었다.\n다시 이런 기회가 온다면 나의 욕심은 반드시 없앨 것이다. 정말 후회된다.\n"},{"id":2,"href":"/ko/posts/221018165518-42%EC%84%9C%EC%9A%B8_%ED%94%BC%EC%8B%A0_%ED%9A%8C%EA%B3%A0-ko/","title":"42서울 피신 회고","section":"기록들","content":" C가 왜 중요한지 느낄 수 있었다. # 자바스크립트로 처음 코드를 배웠기 때문에 동적이고, 유연한 프로토타입 기반의 언어를 기준으로 프로그램을 생각하고 있었다. 그냥 코드를 작성하면 언어가, 컴파일러가 알아서 다 해주니까, 따로 신경써본 적이 없었고, 그러다보니 그 블랙박스 내의 동작은 내가 상상해볼 수 없는 영역이었다.\n\u0026ldquo;잘 작성되었고, 빠르고 인기가 많은\u0026rdquo; 라이브러리들을 찾아 거기서 제공해주는 API를 매뉴얼대로 작성하는 것이 전부였다. 뭔가 부족하다고 생각이 들었고 이대로 괜찮을지에 대한 불안감은 늘 있었지만 정작 나 스스로 블랙박스를 열어볼 용기와 인내는 없었던 것 같다.\n운이 좋게도 피신 과정을 진행하며 C의 Array를 다뤄보았는데, 그 과정에서 언어가 컴퓨터에 어떤 방식으로 자료를 입출력하는지 들여다볼 수 있었다. 피신 전에는 부끄럽게도 Array가 List와 같은 것을 말하는 다른 단어인 줄 알고 있었다.\n내가 작성한 코드를 남에게 잘 설명할 수 있다는 것. # 42 과정은 컴퓨터 과학 로드맵을 과제로서 제시해주고 동료 평가라는 방식으로 과제를 해결해나간다. 과제를 해결하면, 동료가 옆 자리에 와서 코드 리뷰를 해주고, 점수를 부여해준다. 작성한 코드를 잘 설명하지 못하면, 평가자는 본인이 쓴 코드가 아니라고 판단하고 실패를 줄 수도 있다.\n나는 그 동안 거의 혼자서 코드를 작성했었고 다른 사람에게 내 코드를 설명하고, 평가받을 일이 잘 없었다. 그러다 보니 처음에는 조금 어색하고 힘들었지만 진행되며 이런 방식이 내 학습에 얼마나 큰 도움이 되는지 몸소 실감할 수 있었다.\n내가 풀고있는 문제를 본인의 문제처럼 고민해주고 해결책을 제시해주시는 고마운 분도 있었고, 내가 모르고 있던 지식을 설명해주어 부족한 부분을 채워주시는 분도 있었다. 그런 식으로 동료가 전달해주는 지식도 좋았지만, 정말 좋았던 것은 머릿 속으로만 굴리던 코드 흐름을 입 밖으로 내면서 코드와 내 복잡한 머릿 속이 정돈되는 느낌을 받았다.\n설명할 수 없으면 알고 있다고 할 수 없다.\n그래서 앞으로 코드를 작성하고 다른 사람에게 말로서 설명할 기회가 잘 없다고 하더라도, 배운 것을 글로써 출력하는 습관을 들여야겠다고 느꼈다.\n세상에 잘하는 사람들이 이렇게 많다. # 전공자는 잘하고, 비전공자는 못한다고 생각하진 않는다. 내가 비전공자이기 때문에 못한다는 변명을 나도 모르게 하게 될 수 있기 때문이다.\n동료 평가를 다니며 느낀 것은 잘하는 사람들이 정말 많다는 것이었다. 설명을 들으며 이 사람은 머리가 정말 좋구나, 이 사람은 엄청 성실하구나, 진지하게 공부하고 있구나. 그런 생각을 하며 나 자신이 많이 초라하게 느껴질 때도 있었다.\n지금 잘하진 않더라도 앞으로가 기대되는 분들도 많았다. 점수로 본 과정의 당락이 결정되는데도 진도를 그다지 신경쓰지 않고 잘 모르는 것은 깊이 있게 알고 넘어가려는 자세를 가진 분을 보면 앞으로 엄청 잘하게 되실 것 같다는 생각이 들었다.\n아쉬웠던 점 # 과정에 대해 아쉬운 점은 없지만, 코로나에 걸려서 너무 아쉬웠다. 더 많이 배우고, 더 많은 사람들과 얘기를 나눠보고, 더 재밌을 수 있었을텐데.\n"},{"id":3,"href":"/ko/posts/221018160725-pandoc%EC%9C%BC%EB%A1%9C_md%ED%8C%8C%EC%9D%BC_pdf%EB%A1%9C_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-ko/","title":"pandoc으로 md파일 pdf로 변환하기","section":"기록들","content":" 패키지 매니저로 pandoc, wkhtmltopdf 를 설치한다.\nyay pandoc yay wkhtmltopdf css 파일을 같은 디렉터리에 위치시킨다.\nwget https://gist.githubusercontent.com/dashed/6714393/raw/ae966d9d0806eb1e24462d88082a0264438adc50/github-pandoc.css css를 적용한 html문서를 만들고, pdf로 출력한다.\npandoc -t html5 --metadata pagetitle=\u0026#34;resume.md\u0026#34; --css=github-pandoc.css resume.md -o res.pdf 상세한 설명은 스택 오버플로우에\u0026hellip;\n"},{"id":4,"href":"/ko/posts/221018112544-%EC%8A%A4%ED%83%9D_stack-ko/","title":"스택 (Stack)","section":"기록들","content":"스택은 자료를 쌓아올리는 방식으로 저장한다. 책을 쌓아둔 것과 같다. 5권의 책을 쌓아뒀을 때, 첫 번째 책을 꺼내보려면 그 책 위의 네 권을 먼저 들어올려야 한다. 이러한 특징을 FILO(First In Last Out), LIFO(Last In First Out). 처음 들어온 게 마지막에 나간다고 줄여 말한다.\n스택은 추상적 자료 구조이고, 이를 구체적으로 어떻게 구현할지는 구현자 마음대로이다.\n"},{"id":5,"href":"/ko/posts/221017200019-%EC%B6%94%EC%83%81%EC%A0%81_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0-ko/","title":"추상적 자료 구조","section":"기록들","content":"추상 자료형이 말 그대로 자료의 형식만을 정의하는 가장 높은 단계의 추상화라면,\n추상적 자료구조는 해당 자료형을 구체적으로 구현하기 위한 조건들도 함께 정의한다.\n\u0026ldquo;스택(stack)이라는 자료형(data type)의 입출력을 위한 방법에는 push와 pop이 있고, 이 연산들은 O(1)만에 이뤄져야 한다.\u0026quot;\n고 정의된 것이 있다면 이것을 추상적 자료구조라고 말하며, 이를 구현한 것을 구체적 자료구조라고 말한다.\n이렇게 위키피디아 한글 문서에서는 설명하고 있으나 영문판에서는 \u0026lsquo;추상 자료구조\u0026rsquo;와 \u0026lsquo;추상 자료형\u0026rsquo;의 정의 간에 특별한 구분을 두고 있지는 않는 것 같다. 추상 자료형과 자료구조의 차이 정도만 인식하고 있으면 될 것 같다.\n자료구조를 어떻게 정의하여 내부적으로 어떻게 구현했는가는 작성자에게 달려있기에 프로그래밍 언어에 따라 다르다. 예를 들어 스택 (Stack)은 리스트로도 구현할 수 있고 배열 (Array)로도 구현할 수 있다.\n"},{"id":6,"href":"/ko/posts/221017194720-%EC%B6%94%EC%83%81_%EC%9E%90%EB%A3%8C%ED%98%95-ko/","title":"추상 자료형","section":"기록들","content":" 추상 자료형이란 # 추상 자료형은(Abstract Data Type, ADT)는 자료의 형태와 그와 관계된 연산을 수학적으로만 정의한 것이다. 해당 자료형이 내부적으로 어떤 방식으로 구현되는지는 관심이 없다. \u0026lsquo;형\u0026rsquo;과 \u0026lsquo;Type\u0026rsquo;, \u0026lsquo;자료\u0026rsquo;와 \u0026lsquo;Data\u0026rsquo;가 동일한 뜻인 것을 가끔 인지하지 못할 때가 있다.\n정수는 추상 자료형(ADT)이다. \u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip;의 값으로 정의되며, 연산은 더하기, 빼기, 곱하기, 나누기가 가능하고, 대소 비교 등도 가능하다.\n추상적 자료형은 구현 방법을 명시하고 있지 않다는 점에서 자료 구조와 다르다. 비슷한 개념의 추상적 자료 구조는 각 연산의 시간 복잡도를 명기하고 있지만 추상적 자료형에서는 이것조차 명기하지 않는다.\n추상 자료형의 정의 # 어떻게 정의되어야 하는지에 대한 표준화된 약속은 없다. 넓게 나눠보면 \u0026ldquo;명령적\u0026rdquo;(혹은 \u0026ldquo;절차적\u0026rdquo;), \u0026ldquo;기능적\u0026rdquo;(혹은 \u0026ldquo;공리적\u0026rdquo;)인 정의 방식이 있다.\n"},{"id":7,"href":"/ko/posts/221017180001-array-ko/","title":"배열 (Array)","section":"기록들","content":"배열은 연속적인 자료의 나열이다. 배열 내에는 동일한 형(type)의 자료가 나열되어야 한다. 보통의 프로그래밍 언어에서 인덱스는 0부터 시작한다. 루아는 특이하게 1부터 시작한다.\nC에서는 선언 시에 배열로 사용될 메모리 주소의 범위를 정적으로 할당한다. 반면 Javascript에서의 배열은 동적으로 할당되며, 메모리 주소의 연속일 뿐인 C와 다르게 다양한 메서드를 포함하고 있는 객체로 구현되어 있다. 내부 작동은 브라우저의 엔진마다 다를 수 있다고 한다.\nconst arr = [1, 2, 3]; arr[1]; \u0026gt; 2 arr[\u0026#34;1\u0026#34;]; \u0026gt; 2 인덱스는 특이하게 \u0026ldquo;1\u0026quot;로도 1로도 접근 가능한데 내부적으로 toString() 메소드를 호출하기 때문이라고 한다.\n"},{"id":8,"href":"/ko/posts/221017175656-data_structure-ko/","title":"자료구조","section":"기록들","content":"자료구조란 추상 자료형을 구현한 것. 자료(데이터)의 모임, 자료간의 관계, 자료의 입출력 방식.\n왜 자료구조를 알아야 할까 # 주어진 문제를 해결할 때 자료구조를 선택하고 나면 어떤 알고리즘을 사용할지 명확해진다. 구현의 난이도, 결과물의 성능이 자료구조에 크게 의존한다.\n자료구조의 5가지 필수 구성 요소 # 참조 링크\n어떻게 접근 할 것인가. 어떻게 입력 할 것인가. 어떻게 삭제 할 것인가. 어떻게 탐색 할 것인가. 어떻게 정렬 할 것인가. 자료구조 선택 방법 # 자료구조의 분류 # 자료구조는 추상적인 구조인지, 자료간의 관계가 선형(1:1)적인지 비선형적인지 등으로 분류 되어진다.\n추상적 자료 구조 # 스택 (Stack) # 큐 # 트리 # 그래프 # 선형 자료 구조 # 배열(Array) # 리스트(List / Sequence) # "},{"id":9,"href":"/ko/resume/","title":"이력서","section":"소개","content":" 박기둥 # pdf 버전\n\u0026nbsp;그림 그리길 좋아하다 무언가 작동하는 것을 만드는 것을 좋아하게 되었습니다.\n재밌는 것을 만들어 보고 싶다는 생각으로 프로그래밍을 시작했고, 이제는 더 좋은 코드를 작성하고 싶은 생각으로 개발자의 옷을 입고 있습니다.\n\u0026nbsp;앞으로도 무엇이 나를 더 잘 정의하는 말이 될 수 있을지 알아보고 싶습니다.\n- 연락처 # 깃허브 링크드인 이메일 블로그\n- 경험 # 직무 # 기간 회사 직무 개발 스택 2021 01 - 08 나무소프트 프론트엔드 개발 Js/React, Go + Docker + AWS 교육 # 기간 교육 과정 배운 것 회고 2022 08 42 Seoul - 라 피신 Sh, C link 2021 09 - 11 멋쟁이 사자처럼 - 스타트업 스쿨 Django, Dart link 2020 07 - 10 구공팩토리 - 부트캠프 Web, Js 프로젝트 # 기간 이름 한 줄 설명 개발 스택 데모 2022 08 러브캡슐 좋아하는 사람을 찾아줍니다. Dart/Flutter + Firebase 동영상 2021 10 제제 화초 키우는 사람을 위한 SNS. Dart/Flutter + Firebase 동영상 2020 08 주차장 시뮬레이터 주차장 출입 기록 프로그램 바닐라Js + NodeJs + MariaDB 동영상 - 컴퓨터 스킬 # 익숙한 도구 # 언어\nJavascript (Web), Dart, Lua, Fennel, Markdown, Org, SQL\n환경\nLinux (Ubuntu, Arch), GCP (Firebase)\n경험해 본 도구 # 언어\nJavascript (Node), Rescript, C, Go, Clojure, Elisp, Python\n환경\nLinux (CentOS), Windows (wsl2), Docker, AWS (EC2)\n- 언어 # 영어 : 중상\n- 관심 # Lisp, Emacs, 오픈 소스, 텍스트 작성 툴. \u0026lt;2022-10-11 Tue\u0026gt; 읽기 쉬운 코드를 작성하는 방법. \u0026lt;2022-10-18 Tue\u0026gt; "}]